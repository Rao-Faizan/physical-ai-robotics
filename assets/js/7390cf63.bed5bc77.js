"use strict";(globalThis.webpackChunkphysical_ai_robotics=globalThis.webpackChunkphysical_ai_robotics||[]).push([[7188],{2186:(e,n,r)=>{r.d(n,{A:()=>i});const i=r.p+"assets/images/ai-13-ed01b228f10026021530f0817a1b229f.png"},3968:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>g,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module-04-vla/week-12-multimodal","title":"Week 12: Multimodal Vision-Language Fusion","description":"Multimodal Vision-Language Fusion","source":"@site/docs/module-04-vla/week-12-multimodal.md","sourceDirName":"module-04-vla","slug":"/module-04-vla/week-12-multimodal","permalink":"/physical-ai-robotics/docs/module-04-vla/week-12-multimodal","draft":false,"unlisted":false,"editUrl":"https://github.com/Rao-Faizan/physical-ai-robotics/tree/main/frontend/docs/module-04-vla/week-12-multimodal.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Week 11: LLM-Based Task Planning","permalink":"/physical-ai-robotics/docs/module-04-vla/week-11-llm-planning"},"next":{"title":"Week 12: Gesture Recognition for Human-Robot Interaction","permalink":"/physical-ai-robotics/docs/module-04-vla/week-12-gesture-recognition"}}');var t=r(4848),s=r(8453);const o={},a="Week 12: Multimodal Vision-Language Fusion",l={},c=[{value:"Vision and Language Integration",id:"vision-and-language-integration",level:2},{value:"Why Multimodal Models?",id:"why-multimodal-models",level:3},{value:"CLIP for Visual Grounding",id:"clip-for-visual-grounding",level:2},{value:"Installation and Basic Usage",id:"installation-and-basic-usage",level:3},{value:"Referring Expressions for Object Selection",id:"referring-expressions-for-object-selection",level:2},{value:"Spatial Grounding with CLIP",id:"spatial-grounding-with-clip",level:3},{value:"Visual Question Answering (VQA)",id:"visual-question-answering-vqa",level:2},{value:"VQA with GPT-4V (Vision)",id:"vqa-with-gpt-4v-vision",level:3},{value:"Integrating Vision-Language with Robot Control",id:"integrating-vision-language-with-robot-control",level:2},{value:"Practice Exercise",id:"practice-exercise",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"week-12-multimodal-vision-language-fusion",children:"Week 12: Multimodal Vision-Language Fusion"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Multimodal Vision-Language Fusion",src:r(2186).A+"",width:"576",height:"1024"})}),"\n",(0,t.jsx)(n.h2,{id:"vision-and-language-integration",children:"Vision and Language Integration"}),"\n",(0,t.jsx)(n.p,{children:'Multimodal models jointly process visual and textual data to ground language in physical perception. For robotics, this enables referring to objects by natural descriptions ("the mug with the red handle") rather than pre-defined IDs or bounding box coordinates. Vision-language fusion is essential for embodied AI agents operating in open-world environments with novel, unnamed objects.'}),"\n",(0,t.jsx)(n.h3,{id:"why-multimodal-models",children:"Why Multimodal Models?"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Zero-Shot Object Recognition"}),': Traditional object detectors require training on labeled datasets. Multimodal models leverage language descriptions to recognize new categories without retraining\u2014a humanoid encountering "quinoa" for the first time can identify it via text-image similarity.']}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Spatial Reasoning"}),': Language models encode spatial relationships ("left of", "behind") but lack visual grounding. Vision-language models learn to map these linguistic concepts to pixel coordinates.']}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Disambiguation"}),': In scenes with multiple similar objects ("the red mug on the left"), visual grounding resolves which instance matches the description.']}),"\n",(0,t.jsx)(n.h2,{id:"clip-for-visual-grounding",children:"CLIP for Visual Grounding"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"CLIP (Contrastive Language-Image Pre-training)"})," learns a shared embedding space for images and text by training on 400 million image-caption pairs scraped from the internet. Given an image and multiple text descriptions, CLIP computes similarity scores to determine the best match."]}),"\n",(0,t.jsx)(n.h3,{id:"installation-and-basic-usage",children:"Installation and Basic Usage"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Install CLIP from OpenAI\'s official repository\r\nimport subprocess\r\nsubprocess.run(["pip", "install", "git+https://github.com/openai/CLIP.git", "pillow", "torch"])\r\n\r\nimport torch\r\nimport clip\r\nfrom PIL import Image\r\nimport numpy as np\r\n\r\n# Load pre-trained CLIP model\r\n# Options: RN50, RN101, ViT-B/32, ViT-L/14 (larger = more accurate but slower)\r\ndevice = "cuda" if torch.cuda.is_available() else "cpu"\r\nmodel, preprocess = clip.load("ViT-B/32", device=device)\r\n\r\ndef ground_object_in_image(image_path: str, text_queries: list) -> dict:\r\n    """\r\n    Find which text description best matches the image.\r\n\r\n    Args:\r\n        image_path: Path to image file\r\n        text_queries: List of text descriptions to compare\r\n\r\n    Returns:\r\n        dict: {\r\n            \'best_match\': str,\r\n            \'scores\': dict mapping query to similarity score\r\n        }\r\n    """\r\n    # Load and preprocess image\r\n    image = Image.open(image_path)\r\n    image_input = preprocess(image).unsqueeze(0).to(device)\r\n\r\n    # Tokenize text queries\r\n    text_inputs = clip.tokenize(text_queries).to(device)\r\n\r\n    # Compute embeddings\r\n    with torch.no_grad():\r\n        image_features = model.encode_image(image_input)  # Shape: [1, 512]\r\n        text_features = model.encode_text(text_inputs)    # Shape: [N, 512]\r\n\r\n        # Normalize features to unit vectors\r\n        image_features /= image_features.norm(dim=-1, keepdim=True)\r\n        text_features /= text_features.norm(dim=-1, keepdim=True)\r\n\r\n        # Compute cosine similarity (dot product of unit vectors)\r\n        similarity = (image_features @ text_features.T).squeeze(0)  # Shape: [N]\r\n\r\n        # Convert to probabilities using softmax\r\n        probabilities = similarity.softmax(dim=0).cpu().numpy()\r\n\r\n    # Create results dictionary\r\n    scores = {query: float(prob) for query, prob in zip(text_queries, probabilities)}\r\n    best_match = text_queries[probabilities.argmax()]\r\n\r\n    return {\r\n        \'best_match\': best_match,\r\n        \'scores\': scores\r\n    }\r\n\r\n# Example: Object classification in kitchen scene\r\nqueries = [\r\n    "a red coffee mug",\r\n    "a white plate",\r\n    "a stainless steel fork",\r\n    "a glass of water"\r\n]\r\n\r\nresult = ground_object_in_image("kitchen_counter.jpg", queries)\r\nprint(f"Best match: {result[\'best_match\']}")\r\nprint("\\nAll scores:")\r\nfor query, score in result[\'scores\'].items():\r\n    print(f"  {query}: {score:.3f}")\r\n\r\n# Output:\r\n# Best match: a red coffee mug\r\n# All scores:\r\n#   a red coffee mug: 0.782\r\n#   a white plate: 0.124\r\n#   a stainless steel fork: 0.061\r\n#   a glass of water: 0.033\n'})}),"\n",(0,t.jsx)(n.h2,{id:"referring-expressions-for-object-selection",children:"Referring Expressions for Object Selection"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Referring expressions"})," uniquely identify objects using attributes (color, shape), spatial relations (left, behind), and functional descriptions (for drinking). Unlike simple object detection, this requires compositional reasoning."]}),"\n",(0,t.jsx)(n.h3,{id:"spatial-grounding-with-clip",children:"Spatial Grounding with CLIP"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import cv2\r\nfrom typing import List, Tuple\r\n\r\ndef detect_objects_with_clip(\r\n    image_path: str,\r\n    object_descriptions: List[str],\r\n    grid_size: int = 8\r\n) -> List[Tuple[str, int, int, float]]:\r\n    """\r\n    Localize objects in image using sliding window CLIP scoring.\r\n\r\n    Args:\r\n        image_path: Input image\r\n        object_descriptions: List of text descriptions to search for\r\n        grid_size: Divide image into grid_size x grid_size regions\r\n\r\n    Returns:\r\n        List of (description, x, y, score) for detected objects\r\n    """\r\n    # Load image\r\n    image = Image.open(image_path)\r\n    img_width, img_height = image.size\r\n\r\n    # Calculate region dimensions\r\n    region_width = img_width // grid_size\r\n    region_height = img_height // grid_size\r\n\r\n    detections = []\r\n\r\n    for desc in object_descriptions:\r\n        best_score = 0\r\n        best_position = (0, 0)\r\n\r\n        # Slide over grid regions\r\n        for i in range(grid_size):\r\n            for j in range(grid_size):\r\n                # Extract region\r\n                left = j * region_width\r\n                top = i * region_height\r\n                right = left + region_width\r\n                bottom = top + region_height\r\n\r\n                region = image.crop((left, top, right, bottom))\r\n                region_input = preprocess(region).unsqueeze(0).to(device)\r\n\r\n                # Compute CLIP score for this region\r\n                text_input = clip.tokenize([desc]).to(device)\r\n\r\n                with torch.no_grad():\r\n                    image_features = model.encode_image(region_input)\r\n                    text_features = model.encode_text(text_input)\r\n\r\n                    image_features /= image_features.norm(dim=-1, keepdim=True)\r\n                    text_features /= text_features.norm(dim=-1, keepdim=True)\r\n\r\n                    score = (image_features @ text_features.T).item()\r\n\r\n                # Track highest scoring region for this object\r\n                if score > best_score:\r\n                    best_score = score\r\n                    best_position = (left + region_width // 2, top + region_height // 2)\r\n\r\n        detections.append((desc, best_position[0], best_position[1], best_score))\r\n\r\n    return detections\r\n\r\n# Example: Locate multiple objects\r\nobjects = ["red mug", "laptop computer", "potted plant"]\r\ndetections = detect_objects_with_clip("desk_scene.jpg", objects, grid_size=6)\r\n\r\nfor obj, x, y, score in detections:\r\n    print(f"{obj}: position ({x}, {y}), confidence {score:.3f}")\r\n\r\n# Visualize results\r\nimage = cv2.imread("desk_scene.jpg")\r\nfor obj, x, y, score in detections:\r\n    cv2.circle(image, (x, y), 10, (0, 255, 0), -1)\r\n    cv2.putText(image, obj, (x + 15, y), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)\r\n\r\ncv2.imwrite("detected_objects.jpg", image)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"visual-question-answering-vqa",children:"Visual Question Answering (VQA)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Visual Question Answering"}),' combines image understanding with language comprehension to answer open-ended questions about visual scenes. For humanoid robots, VQA enables situational awareness: "Is the door open?", "How many people are in the room?", "What color is the object on the table?"']}),"\n",(0,t.jsx)(n.h3,{id:"vqa-with-gpt-4v-vision",children:"VQA with GPT-4V (Vision)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import base64\r\nimport requests\r\n\r\ndef answer_visual_question(image_path: str, question: str) -> str:\r\n    """\r\n    Use GPT-4V to answer questions about an image.\r\n\r\n    Args:\r\n        image_path: Path to image file\r\n        question: Natural language question\r\n\r\n    Returns:\r\n        str: Answer from GPT-4V\r\n    """\r\n    # Encode image to base64 for API transmission\r\n    with open(image_path, "rb") as image_file:\r\n        image_data = base64.b64encode(image_file.read()).decode(\'utf-8\')\r\n\r\n    headers = {\r\n        "Content-Type": "application/json",\r\n        "Authorization": f"Bearer {os.getenv(\'OPENAI_API_KEY\')}"\r\n    }\r\n\r\n    # Construct multimodal prompt\r\n    payload = {\r\n        "model": "gpt-4-vision-preview",\r\n        "messages": [\r\n            {\r\n                "role": "user",\r\n                "content": [\r\n                    {\r\n                        "type": "text",\r\n                        "text": question\r\n                    },\r\n                    {\r\n                        "type": "image_url",\r\n                        "image_url": {\r\n                            "url": f"data:image/jpeg;base64,{image_data}"\r\n                        }\r\n                    }\r\n                ]\r\n            }\r\n        ],\r\n        "max_tokens": 300\r\n    }\r\n\r\n    # Send API request\r\n    response = requests.post(\r\n        "https://api.openai.com/v1/chat/completions",\r\n        headers=headers,\r\n        json=payload\r\n    )\r\n\r\n    # Extract answer\r\n    result = response.json()\r\n    answer = result[\'choices\'][0][\'message\'][\'content\']\r\n    return answer\r\n\r\n# Example: Scene understanding queries\r\nquestions = [\r\n    "How many mugs are on the table?",\r\n    "What color is the leftmost mug?",\r\n    "Is there a laptop visible in the image?",\r\n    "Describe the spatial arrangement of objects on the desk."\r\n]\r\n\r\nfor q in questions:\r\n    answer = answer_visual_question("desk_scene.jpg", q)\r\n    print(f"Q: {q}")\r\n    print(f"A: {answer}\\n")\r\n\r\n# Output:\r\n# Q: How many mugs are on the table?\r\n# A: There are three mugs visible on the table.\r\n#\r\n# Q: What color is the leftmost mug?\r\n# A: The leftmost mug is red with a white handle.\n'})}),"\n",(0,t.jsx)(n.h2,{id:"integrating-vision-language-with-robot-control",children:"Integrating Vision-Language with Robot Control"}),"\n",(0,t.jsx)(n.p,{children:"Combine CLIP grounding with ROS 2 action servers for closed-loop manipulation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import Point\r\n\r\nclass VisionLanguageGrasping(Node):\r\n    """\r\n    ROS 2 node that uses CLIP to locate objects and commands robot to grasp.\r\n    """\r\n\r\n    def __init__(self):\r\n        super().__init__(\'vision_language_grasping\')\r\n\r\n        # Subscribe to camera images\r\n        self.subscription = self.create_subscription(\r\n            Image,\r\n            \'/camera/image_raw\',\r\n            self.image_callback,\r\n            10\r\n        )\r\n\r\n        # Publisher for grasp target positions\r\n        self.grasp_pub = self.create_publisher(Point, \'/grasp_target\', 10)\r\n\r\n        self.current_image = None\r\n\r\n    def image_callback(self, msg):\r\n        """Store latest camera image."""\r\n        # Convert ROS Image message to PIL Image\r\n        self.current_image = self.ros_to_pil_image(msg)\r\n\r\n    def grasp_object_by_description(self, description: str):\r\n        """\r\n        Find object matching description and publish grasp target.\r\n\r\n        Args:\r\n            description: Text description (e.g., "the blue screwdriver")\r\n        """\r\n        if self.current_image is None:\r\n            self.get_logger().warn("No camera image available")\r\n            return\r\n\r\n        # Use CLIP to locate object\r\n        detections = detect_objects_with_clip(\r\n            self.current_image,\r\n            [description],\r\n            grid_size=8\r\n        )\r\n\r\n        if detections:\r\n            desc, x, y, score = detections[0]\r\n            self.get_logger().info(\r\n                f"Found \'{desc}\' at pixel ({x}, {y}) with confidence {score:.2f}"\r\n            )\r\n\r\n            # Convert pixel coordinates to 3D point (requires camera calibration)\r\n            grasp_point = self.pixel_to_3d(x, y)\r\n\r\n            # Publish grasp target for manipulation controller\r\n            self.grasp_pub.publish(grasp_point)\r\n\r\n    def pixel_to_3d(self, x: int, y: int) -> Point:\r\n        """\r\n        Convert 2D pixel to 3D point using depth sensor and camera intrinsics.\r\n        (Simplified; real implementation requires camera_info and depth_image)\r\n        """\r\n        point = Point()\r\n        point.x = float(x) * 0.001  # Mock conversion\r\n        point.y = float(y) * 0.001\r\n        point.z = 0.5  # Assume fixed depth\r\n        return point\r\n\r\n# Example usage in ROS 2 context\r\ndef main():\r\n    rclpy.init()\r\n    node = VisionLanguageGrasping()\r\n\r\n    # Command robot to grasp object\r\n    node.grasp_object_by_description("the red coffee mug")\r\n\r\n    rclpy.spin(node)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"practice-exercise",children:"Practice Exercise"}),"\n",(0,t.jsx)(n.p,{children:"Build a visual search system:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Capture image from robot's camera"}),"\n",(0,t.jsx)(n.li,{children:'User provides text query: "Find the green bottle"'}),"\n",(0,t.jsx)(n.li,{children:"Use CLIP to locate object and compute bounding box"}),"\n",(0,t.jsx)(n.li,{children:"Navigate robot to face object (pan camera or move base)"}),"\n",(0,t.jsx)(n.li,{children:"Verify object is within manipulation workspace"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Extend with ",(0,t.jsx)(n.strong,{children:"attribute reasoning"}),': Handle queries like "the larger of the two mugs" (requires size comparison) or "the mug closest to the edge" (spatial reasoning).']}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(n.p,{children:["You've connected language to vision for object grounding. In ",(0,t.jsx)(n.strong,{children:"Week 12: Gesture Recognition"}),", you'll add human pose tracking using MediaPipe, enabling robots to interpret pointing gestures and body language for natural human-robot interaction."]})]})}function g(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var i=r(6540);const t={},s=i.createContext(t);function o(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);