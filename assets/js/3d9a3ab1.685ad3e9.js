"use strict";(globalThis.webpackChunkphysical_ai_robotics=globalThis.webpackChunkphysical_ai_robotics||[]).push([[4327],{703:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>t,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"module-02-simulation/week-6-gazebo-basics","title":"Week 6: Gazebo Basics","description":"Installation and Setup","source":"@site/docs/module-02-simulation/week-6-gazebo-basics.md","sourceDirName":"module-02-simulation","slug":"/module-02-simulation/week-6-gazebo-basics","permalink":"/physical-ai-robotics/docs/module-02-simulation/week-6-gazebo-basics","draft":false,"unlisted":false,"editUrl":"https://github.com/Rao-Faizan/physical-ai-robotics/tree/main/frontend/docs/module-02-simulation/week-6-gazebo-basics.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Module 2: Gazebo & Unity Simulation","permalink":"/physical-ai-robotics/docs/module-02-simulation/intro"},"next":{"title":"Week 6: Physics Configuration for Humanoid Robots","permalink":"/physical-ai-robotics/docs/module-02-simulation/week-6-physics"}}');var s=i(4848),o=i(8453);const t={},l="Week 6: Gazebo Basics",a={},c=[{value:"Installation and Setup",id:"installation-and-setup",level:2},{value:"SDF Models: The Robot Description Language",id:"sdf-models-the-robot-description-language",level:2},{value:"Physics Engines: ODE vs Bullet",id:"physics-engines-ode-vs-bullet",level:2},{value:"ODE (Open Dynamics Engine)",id:"ode-open-dynamics-engine",level:3},{value:"Bullet",id:"bullet",level:3},{value:"Spawning Robots and Running Simulation",id:"spawning-robots-and-running-simulation",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"week-6-gazebo-basics",children:"Week 6: Gazebo Basics"})}),"\n",(0,s.jsx)(n.h2,{id:"installation-and-setup",children:"Installation and Setup"}),"\n",(0,s.jsxs)(n.p,{children:["Gazebo integrates tightly with ROS2. We'll use ",(0,s.jsx)(n.strong,{children:"Gazebo Fortress"})," (formerly Ignition Gazebo), the modern replacement for Gazebo Classic."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Install Gazebo Fortress on Ubuntu 22.04\r\nsudo apt-get update\r\nsudo apt-get install -y gazebo-fortress\r\n\r\n# Verify installation\r\nign gazebo --version\r\n# Expected output: Gazebo Fortress 6.x.x\r\n\r\n# Install ROS2 Gazebo bridge for Humble\r\nsudo apt-get install ros-humble-ros-gz-bridge ros-humble-ros-gz-sim\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key Difference"}),": Gazebo Classic used ",(0,s.jsx)(n.code,{children:"gazebo"})," commands; Ignition/Fortress uses ",(0,s.jsx)(n.code,{children:"ign gazebo"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"sdf-models-the-robot-description-language",children:"SDF Models: The Robot Description Language"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"SDF (Simulation Description Format)"})," is XML-based and more expressive than URDF. Unlike URDF (designed for kinematics), SDF natively supports:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Closed kinematic loops"}),"\n",(0,s.jsx)(n.li,{children:"Multiple models in one file"}),"\n",(0,s.jsx)(n.li,{children:"Plugin configurations for sensors and controllers"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example"}),": Simple humanoid torso with two arms (simplified for clarity)."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- humanoid_torso.sdf --\x3e\r\n<?xml version="1.0"?>\r\n<sdf version="1.8">\r\n  <model name="humanoid_torso">\r\n    \x3c!-- Base link (torso) --\x3e\r\n    <link name="torso">\r\n      <pose>0 0 1.0 0 0 0</pose> \x3c!-- x y z roll pitch yaw --\x3e\r\n      <inertial>\r\n        <mass>15.0</mass> \x3c!-- 15 kg torso --\x3e\r\n        <inertia>\r\n          <ixx>0.5</ixx> <ixy>0</ixy> <ixz>0</ixz>\r\n          <iyy>0.6</iyy> <iyz>0</iyz> <izz>0.3</izz>\r\n        </inertia>\r\n      </inertial>\r\n      <collision name="torso_collision">\r\n        <geometry>\r\n          <box><size>0.3 0.4 0.6</size></box> \x3c!-- Width Depth Height --\x3e\r\n        </geometry>\r\n      </collision>\r\n      <visual name="torso_visual">\r\n        <geometry>\r\n          <box><size>0.3 0.4 0.6</size></box>\r\n        </geometry>\r\n        <material>\r\n          <ambient>0.2 0.2 0.8 1</ambient> \x3c!-- Blue torso --\x3e\r\n        </material>\r\n      </visual>\r\n    </link>\r\n\r\n    \x3c!-- Right shoulder joint --\x3e\r\n    <joint name="right_shoulder" type="revolute">\r\n      <parent>torso</parent>\r\n      <child>right_upper_arm</child>\r\n      <axis>\r\n        <xyz>1 0 0</xyz> \x3c!-- Rotate around X-axis (pitch) --\x3e\r\n        <limit>\r\n          <lower>-1.57</lower> \x3c!-- -90 degrees --\x3e\r\n          <upper>1.57</upper>  \x3c!-- +90 degrees --\x3e\r\n          <effort>50</effort>   \x3c!-- Max torque: 50 Nm --\x3e\r\n          <velocity>2.0</velocity> \x3c!-- Max speed: 2 rad/s --\x3e\r\n        </limit>\r\n      </axis>\r\n    </joint>\r\n\r\n    \x3c!-- Right upper arm link --\x3e\r\n    <link name="right_upper_arm">\r\n      <pose relative_to="right_shoulder">0 -0.25 0 0 0 0</pose>\r\n      <inertial>\r\n        <mass>2.0</mass>\r\n        <inertia>\r\n          <ixx>0.01</ixx> <ixy>0</ixy> <ixz>0</ixz>\r\n          <iyy>0.01</iyy> <iyz>0</iyz> <izz>0.005</izz>\r\n        </inertia>\r\n      </inertial>\r\n      <collision name="arm_collision">\r\n        <geometry>\r\n          <cylinder><radius>0.05</radius><length>0.3</length></cylinder>\r\n        </geometry>\r\n      </collision>\r\n      <visual name="arm_visual">\r\n        <geometry>\r\n          <cylinder><radius>0.05</radius><length>0.3</length></cylinder>\r\n        </geometry>\r\n      </visual>\r\n    </link>\r\n  </model>\r\n</sdf>\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key Concepts"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<pose>"}),": Position (x, y, z) and orientation (roll, pitch, yaw in radians)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<inertial>"}),": Mass and moment of inertia tensor (critical for stable simulation)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"relative_to"}),": Child link positions relative to parent joint frame"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"physics-engines-ode-vs-bullet",children:"Physics Engines: ODE vs Bullet"}),"\n",(0,s.jsx)(n.p,{children:"Gazebo supports multiple physics engines. The two most common for humanoid robotics are:"}),"\n",(0,s.jsx)(n.h3,{id:"ode-open-dynamics-engine",children:"ODE (Open Dynamics Engine)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Pros"}),": Fast, handles large contact counts well"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cons"}),': Less accurate contact resolution, can be "bouncy"']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Best For"}),": Multi-legged robots, rough terrain navigation"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"bullet",children:"Bullet"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Pros"}),": Accurate collision detection, stable stacking"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cons"}),": Slower for many contacts"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Best For"}),": Manipulation tasks, precise contact modeling"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"World File Configuration"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- world_file.sdf --\x3e\r\n<?xml version="1.0"?>\r\n<sdf version="1.8">\r\n  <world name="humanoid_world">\r\n    \x3c!-- Choose physics engine: ode, bullet, dart --\x3e\r\n    <physics name="default_physics" type="bullet">\r\n      <max_step_size>0.001</max_step_size> \x3c!-- 1ms timestep --\x3e\r\n      <real_time_factor>1.0</real_time_factor> \x3c!-- Run at real-time speed --\x3e\r\n      <real_time_update_rate>1000</real_time_update_rate> \x3c!-- 1000 Hz --\x3e\r\n    </physics>\r\n\r\n    \x3c!-- Lighting for visualization --\x3e\r\n    <light name="sun" type="directional">\r\n      <pose>0 0 10 0 0 0</pose>\r\n      <diffuse>0.8 0.8 0.8 1</diffuse>\r\n    </light>\r\n\r\n    \x3c!-- Ground plane --\x3e\r\n    <model name="ground">\r\n      <static>true</static>\r\n      <link name="ground_link">\r\n        <collision name="ground_collision">\r\n          <geometry>\r\n            <plane><normal>0 0 1</normal></plane>\r\n          </geometry>\r\n          <surface>\r\n            <friction>\r\n              <ode><mu>1.0</mu></ode> \x3c!-- Friction coefficient --\x3e\r\n            </friction>\r\n          </surface>\r\n        </collision>\r\n      </link>\r\n    </model>\r\n\r\n    \x3c!-- Include our humanoid model --\x3e\r\n    <include>\r\n      <uri>file://humanoid_torso.sdf</uri>\r\n      <pose>0 0 1.5 0 0 0</pose> \x3c!-- Spawn 1.5m above ground --\x3e\r\n    </include>\r\n  </world>\r\n</sdf>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"spawning-robots-and-running-simulation",children:"Spawning Robots and Running Simulation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Launch Gazebo with the world file\r\nign gazebo world_file.sdf\r\n\r\n# Alternative: Spawn model dynamically via command\r\nign service -s /world/humanoid_world/create \\\r\n  --reqtype ignition.msgs.EntityFactory \\\r\n  --reptype ignition.msgs.Boolean \\\r\n  --timeout 1000 \\\r\n  --req 'sdf_filename: \"humanoid_torso.sdf\", pose: {position: {z: 2.0}}'\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Exercise"}),": Modify ",(0,s.jsx)(n.code,{children:"humanoid_torso.sdf"})," to add a left arm (mirror the right arm). Adjust inertia values and verify the robot doesn't tip over when spawned."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Next"}),": ",(0,s.jsx)(n.a,{href:"/physical-ai-robotics/docs/module-02-simulation/week-6-physics",children:"Week 6 - Physics Configuration"})," - Tuning collision, friction, and contact forces for realistic humanoid behavior."]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>l});var r=i(6540);const s={},o=r.createContext(s);function t(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);