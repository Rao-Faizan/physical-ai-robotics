"use strict";(globalThis.webpackChunkphysical_ai_robotics=globalThis.webpackChunkphysical_ai_robotics||[]).push([[5967],{5739:(r,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-01-ros2/week-5-control","title":"Week 5: ros2_control Framework","description":"Introduction to ros2_control","source":"@site/docs/module-01-ros2/week-5-control.md","sourceDirName":"module-01-ros2","slug":"/module-01-ros2/week-5-control","permalink":"/physical-ai-robotics/docs/module-01-ros2/week-5-control","draft":false,"unlisted":false,"editUrl":"https://github.com/Rao-Faizan/physical-ai-robotics/tree/main/frontend/docs/module-01-ros2/week-5-control.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Week 5: URDF for Humanoid Robots","permalink":"/physical-ai-robotics/docs/module-01-ros2/week-5-urdf"},"next":{"title":"Week 5: Complete Humanoid URDF Example","permalink":"/physical-ai-robotics/docs/module-01-ros2/week-5-complete-urdf"}}');var t=n(4848),i=n(8453);const a={},s="Week 5: ros2_control Framework",l={},c=[{value:"Introduction to ros2_control",id:"introduction-to-ros2_control",level:2},{value:"Why ros2_control?",id:"why-ros2_control",level:3},{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"1. Hardware Interface",id:"1-hardware-interface",level:3},{value:"2. Controller Manager",id:"2-controller-manager",level:3},{value:"3. Controllers",id:"3-controllers",level:3},{value:"Controller Types for Humanoid Robots",id:"controller-types-for-humanoid-robots",level:2},{value:"Position Controllers",id:"position-controllers",level:3},{value:"Velocity Controllers",id:"velocity-controllers",level:3},{value:"Effort Controllers",id:"effort-controllers",level:3},{value:"ros2_control Configuration in URDF",id:"ros2_control-configuration-in-urdf",level:2},{value:"Hardware Interface Definition",id:"hardware-interface-definition",level:3},{value:"Controller Configuration YAML",id:"controller-configuration-yaml",level:3},{value:"Control Loop Basics",id:"control-loop-basics",level:2},{value:"1. Read State",id:"1-read-state",level:3},{value:"2. Update Controllers",id:"2-update-controllers",level:3},{value:"3. Write Commands",id:"3-write-commands",level:3},{value:"4. Repeat",id:"4-repeat",level:3},{value:"Launching ros2_control System",id:"launching-ros2_control-system",level:2},{value:"Testing Controllers",id:"testing-controllers",level:2},{value:"Hardware Interfaces for Real Robots",id:"hardware-interfaces-for-real-robots",level:2},{value:"Next Steps",id:"next-steps",level:2},{value:"Practice Exercise",id:"practice-exercise",level:3}];function d(r){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...r.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"week-5-ros2_control-framework",children:"Week 5: ros2_control Framework"})}),"\n",(0,t.jsx)(e.h2,{id:"introduction-to-ros2_control",children:"Introduction to ros2_control"}),"\n",(0,t.jsx)(e.p,{children:"The ros2_control framework provides a standardized architecture for robot control systems in ROS 2. It decouples controller algorithms from hardware-specific code through well-defined interfaces, enabling you to develop control strategies that work seamlessly across simulation and real robots."}),"\n",(0,t.jsx)(e.h3,{id:"why-ros2_control",children:"Why ros2_control?"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Hardware Abstraction"}),": Write controller code once, deploy to different actuator types (servo motors, hydraulic actuators, electric motors) by swapping hardware interface plugins."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Real-time Safety"}),": ros2_control runs controllers in dedicated threads with real-time priorities, ensuring deterministic execution\u2014critical for humanoid balance control where delays can cause falls."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Ecosystem Integration"}),": Compatible with MoveIt (motion planning), Gazebo (simulation), and industrial robot drivers. Humanoid projects benefit from reusing proven controller implementations."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"State Management"}),": Provides lifecycle management for controllers (inactive, active, emergency_stop), enabling safe mode transitions during operation."]}),"\n",(0,t.jsx)(e.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,t.jsx)(e.p,{children:"ros2_control consists of three main components:"}),"\n",(0,t.jsx)(e.h3,{id:"1-hardware-interface",children:"1. Hardware Interface"}),"\n",(0,t.jsx)(e.p,{children:"Bridges between controller commands and physical/simulated hardware. Defines how to read sensor data (joint encoders, force sensors) and write actuator commands (motor voltages, position setpoints)."}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Interface Types"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"CommandInterface"}),": Write commands to hardware (e.g., ",(0,t.jsx)(e.code,{children:"position"}),", ",(0,t.jsx)(e.code,{children:"velocity"}),", ",(0,t.jsx)(e.code,{children:"effort"}),")"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"StateInterface"}),": Read sensor data (e.g., ",(0,t.jsx)(e.code,{children:"position"}),", ",(0,t.jsx)(e.code,{children:"velocity"}),", ",(0,t.jsx)(e.code,{children:"effort"}),")"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"2-controller-manager",children:"2. Controller Manager"}),"\n",(0,t.jsx)(e.p,{children:"Manages controller lifecycle: loading, configuring, activating, deactivating. Ensures only one controller writes to each command interface (prevents conflicts)."}),"\n",(0,t.jsx)(e.h3,{id:"3-controllers",children:"3. Controllers"}),"\n",(0,t.jsx)(e.p,{children:"Implement control algorithms (PID, model predictive control, impedance control). ROS 2 provides standard controllers:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"JointTrajectoryController"}),": Executes smooth multi-joint trajectories"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"JointGroupPositionController"}),": Simple position commands for joint groups"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"DiffDriveController"}),": For mobile bases (wheeled humanoids)"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"controller-types-for-humanoid-robots",children:"Controller Types for Humanoid Robots"}),"\n",(0,t.jsx)(e.h3,{id:"position-controllers",children:"Position Controllers"}),"\n",(0,t.jsx)(e.p,{children:"Command desired joint angles. The hardware interface (or lower-level controller in the actuator) closes the control loop to achieve the target position."}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Use cases"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Reaching to a target pose (arm stretched forward)"}),"\n",(0,t.jsx)(e.li,{children:"Holding a static posture (standing still)"}),"\n",(0,t.jsx)(e.li,{children:"Playing back pre-recorded motions"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Limitations"}),": Cannot directly control contact forces\u2014problematic for tasks like grasping or balancing on compliant surfaces."]}),"\n",(0,t.jsx)(e.h3,{id:"velocity-controllers",children:"Velocity Controllers"}),"\n",(0,t.jsx)(e.p,{children:"Command desired joint velocities. Useful for continuous motions where exact position is less critical than smooth speed profiles."}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Use cases"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Walking with prescribed joint velocity profiles"}),"\n",(0,t.jsx)(e.li,{children:"Compliant motions that adapt to external forces"}),"\n",(0,t.jsx)(e.li,{children:"Teleoperation (joystick input maps to joint speeds)"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Limitations"}),": Position drift over time without feedback correction."]}),"\n",(0,t.jsx)(e.h3,{id:"effort-controllers",children:"Effort Controllers"}),"\n",(0,t.jsx)(e.p,{children:"Command desired joint torques/forces. Provides direct control over interaction forces\u2014essential for advanced humanoid behaviors."}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Use cases"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Impedance control for safe human-robot interaction"}),"\n",(0,t.jsx)(e.li,{children:"Force-based grasping (close gripper until target force detected)"}),"\n",(0,t.jsx)(e.li,{children:"Balance control using ankle/hip torques to regulate center of mass"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Challenges"}),": Requires accurate dynamic models and force/torque sensing. Most humanoid research operates in effort control mode."]}),"\n",(0,t.jsx)(e.h2,{id:"ros2_control-configuration-in-urdf",children:"ros2_control Configuration in URDF"}),"\n",(0,t.jsx)(e.p,{children:"To use ros2_control, add special tags to your URDF that define hardware interfaces and controllers."}),"\n",(0,t.jsx)(e.h3,{id:"hardware-interface-definition",children:"Hardware Interface Definition"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\r\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="humanoid">\r\n\r\n  \x3c!-- Include ros2_control Xacro macros --\x3e\r\n  <xacro:include filename="$(find ros2_control)/urdf/ros2_control.xacro"/>\r\n\r\n  \x3c!-- Define ros2_control hardware interface --\x3e\r\n  <ros2_control name="HumanoidRobotSystem" type="system">\r\n\r\n    \x3c!-- Hardware plugin (use Gazebo for simulation) --\x3e\r\n    <hardware>\r\n      <plugin>gazebo_ros2_control/GazeboSystem</plugin>\r\n    </hardware>\r\n\r\n    \x3c!-- Joint 1: Left shoulder pitch --\x3e\r\n    <joint name="left_shoulder_pitch">\r\n      \x3c!-- State interfaces: what sensors can read --\x3e\r\n      <state_interface name="position"/>\r\n      <state_interface name="velocity"/>\r\n      <state_interface name="effort"/>\r\n\r\n      \x3c!-- Command interfaces: what controllers can write --\x3e\r\n      <command_interface name="position">\r\n        \x3c!-- Optional: set initial command value --\x3e\r\n        <param name="initial_value">0.0</param>\r\n      </command_interface>\r\n      <command_interface name="effort"/>\r\n\r\n      \x3c!-- Joint limits (optional, can also read from URDF) --\x3e\r\n      <param name="min_position">-1.57</param>\r\n      <param name="max_position">1.57</param>\r\n      <param name="max_velocity">2.0</param>\r\n      <param name="max_effort">100.0</param>\r\n    </joint>\r\n\r\n    \x3c!-- Joint 2: Left shoulder roll --\x3e\r\n    <joint name="left_shoulder_roll">\r\n      <state_interface name="position"/>\r\n      <state_interface name="velocity"/>\r\n      <state_interface name="effort"/>\r\n      <command_interface name="position"/>\r\n      <command_interface name="effort"/>\r\n      <param name="min_position">-0.785</param>\r\n      <param name="max_position">0.785</param>\r\n    </joint>\r\n\r\n    \x3c!-- Joint 3: Left elbow --\x3e\r\n    <joint name="left_elbow">\r\n      <state_interface name="position"/>\r\n      <state_interface name="velocity"/>\r\n      <state_interface name="effort"/>\r\n      <command_interface name="position"/>\r\n      <command_interface name="effort"/>\r\n      <param name="min_position">0.0</param>\r\n      <param name="max_position">2.356</param>\r\n    </joint>\r\n\r\n    \x3c!-- Repeat for right arm and leg joints... --\x3e\r\n\r\n    \x3c!-- Optional: IMU sensor for balance control --\x3e\r\n    <sensor name="imu_sensor">\r\n      <state_interface name="orientation.x"/>\r\n      <state_interface name="orientation.y"/>\r\n      <state_interface name="orientation.z"/>\r\n      <state_interface name="orientation.w"/>\r\n      <state_interface name="angular_velocity.x"/>\r\n      <state_interface name="angular_velocity.y"/>\r\n      <state_interface name="angular_velocity.z"/>\r\n      <state_interface name="linear_acceleration.x"/>\r\n      <state_interface name="linear_acceleration.y"/>\r\n      <state_interface name="linear_acceleration.z"/>\r\n    </sensor>\r\n\r\n  </ros2_control>\r\n\r\n  \x3c!-- Gazebo plugin to load ros2_control --\x3e\r\n  <gazebo>\r\n    <plugin filename="libgazebo_ros2_control.so" name="gazebo_ros2_control">\r\n      <robot_param>robot_description</robot_param>\r\n      <robot_param_node>robot_state_publisher</robot_param_node>\r\n      <parameters>$(find humanoid_control)/config/controllers.yaml</parameters>\r\n    </plugin>\r\n  </gazebo>\r\n\r\n</robot>\n'})}),"\n",(0,t.jsx)(e.h3,{id:"controller-configuration-yaml",children:"Controller Configuration YAML"}),"\n",(0,t.jsxs)(e.p,{children:["Define controller parameters in ",(0,t.jsx)(e.code,{children:"config/controllers.yaml"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"controller_manager:\r\n  ros__parameters:\r\n    update_rate: 100  # Hz - control loop frequency\r\n\r\n    # List of controllers to load on startup\r\n    joint_state_broadcaster:\r\n      type: joint_state_broadcaster/JointStateBroadcaster\r\n\r\n    arm_position_controller:\r\n      type: position_controllers/JointGroupPositionController\r\n\r\n    arm_trajectory_controller:\r\n      type: joint_trajectory_controller/JointTrajectoryController\r\n\r\n# Joint state broadcaster: publishes /joint_states topic\r\njoint_state_broadcaster:\r\n  ros__parameters:\r\n    # No additional config needed - broadcasts all joints automatically\r\n\r\n# Arm position controller: simple position commands\r\narm_position_controller:\r\n  ros__parameters:\r\n    joints:\r\n      - left_shoulder_pitch\r\n      - left_shoulder_roll\r\n      - left_elbow\r\n      - right_shoulder_pitch\r\n      - right_shoulder_roll\r\n      - right_elbow\r\n\r\n    # Interface to command (position, velocity, or effort)\r\n    interface_name: position\r\n\r\n# Arm trajectory controller: smooth trajectory execution\r\narm_trajectory_controller:\r\n  ros__parameters:\r\n    joints:\r\n      - left_shoulder_pitch\r\n      - left_shoulder_roll\r\n      - left_elbow\r\n      - right_shoulder_pitch\r\n      - right_shoulder_roll\r\n      - right_elbow\r\n\r\n    # Command interface\r\n    command_interfaces:\r\n      - position\r\n\r\n    # State interfaces for feedback\r\n    state_interfaces:\r\n      - position\r\n      - velocity\r\n\r\n    # Constraints for trajectory execution\r\n    constraints:\r\n      stopped_velocity_tolerance: 0.01  # rad/s\r\n      goal_time: 0.5  # seconds - time tolerance for reaching goal\r\n\r\n    # PID gains for trajectory tracking (per joint)\r\n    gains:\r\n      left_shoulder_pitch: {p: 100.0, d: 10.0, i: 0.0, i_clamp: 1.0}\r\n      left_shoulder_roll: {p: 80.0, d: 8.0, i: 0.0, i_clamp: 1.0}\r\n      left_elbow: {p: 60.0, d: 6.0, i: 0.0, i_clamp: 1.0}\r\n      right_shoulder_pitch: {p: 100.0, d: 10.0, i: 0.0, i_clamp: 1.0}\r\n      right_shoulder_roll: {p: 80.0, d: 8.0, i: 0.0, i_clamp: 1.0}\r\n      right_elbow: {p: 60.0, d: 6.0, i: 0.0, i_clamp: 1.0}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"control-loop-basics",children:"Control Loop Basics"}),"\n",(0,t.jsxs)(e.p,{children:["The ros2_control control loop follows this sequence (executed at ",(0,t.jsx)(e.code,{children:"update_rate"}),", e.g., 100 Hz):"]}),"\n",(0,t.jsx)(e.h3,{id:"1-read-state",children:"1. Read State"}),"\n",(0,t.jsx)(e.p,{children:"Hardware interface reads current joint positions, velocities, and efforts from encoders/sensors."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"// Pseudocode - actual implementation in hardware plugin\r\nfor (auto& joint : joints_) {\r\n  joint.position = read_encoder(joint.name);\r\n  joint.velocity = compute_velocity(joint.position, previous_position, dt);\r\n  joint.effort = read_current_sensor(joint.name);\r\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-update-controllers",children:"2. Update Controllers"}),"\n",(0,t.jsx)(e.p,{children:"Each active controller runs its control algorithm, reading state and computing commands."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"// JointTrajectoryController update (simplified)\r\nfor (size_t i = 0; i < joints_.size(); ++i) {\r\n  // Get target position from trajectory at current time\r\n  double target_position = trajectory_.sample(current_time, i);\r\n\r\n  // PID control law\r\n  double error = target_position - joint_state_[i].position;\r\n  double error_derivative = -joint_state_[i].velocity;  // Assumes target velocity = 0\r\n\r\n  // Compute command (effort in this case)\r\n  joint_commands_[i].effort = gains_[i].p * error + gains_[i].d * error_derivative;\r\n\r\n  // Clamp to joint limits\r\n  joint_commands_[i].effort = std::clamp(\r\n    joint_commands_[i].effort,\r\n    -max_effort_[i],\r\n    max_effort_[i]\r\n  );\r\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-write-commands",children:"3. Write Commands"}),"\n",(0,t.jsx)(e.p,{children:"Hardware interface sends commands to actuators."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"// Pseudocode\r\nfor (auto& joint : joints_) {\r\n  write_motor_command(joint.name, joint.command_effort);\r\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-repeat",children:"4. Repeat"}),"\n",(0,t.jsx)(e.p,{children:"Loop repeats at fixed rate. Real-time scheduling ensures deterministic timing."}),"\n",(0,t.jsx)(e.h2,{id:"launching-ros2_control-system",children:"Launching ros2_control System"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"\r\nLaunch file for humanoid robot with ros2_control.\r\n\"\"\"\r\n\r\nfrom launch import LaunchDescription\r\nfrom launch_ros.actions import Node\r\nfrom launch.actions import ExecuteProcess\r\nfrom ament_index_python.packages import get_package_share_directory\r\nimport os\r\n\r\ndef generate_launch_description():\r\n    # Get URDF file path\r\n    urdf_path = os.path.join(\r\n        get_package_share_directory('humanoid_description'),\r\n        'urdf',\r\n        'humanoid.urdf.xacro'\r\n    )\r\n\r\n    # Get controller config path\r\n    controller_config = os.path.join(\r\n        get_package_share_directory('humanoid_control'),\r\n        'config',\r\n        'controllers.yaml'\r\n    )\r\n\r\n    return LaunchDescription([\r\n        # Start Gazebo simulation\r\n        ExecuteProcess(\r\n            cmd=['gazebo', '--verbose', '-s', 'libgazebo_ros_factory.so'],\r\n            output='screen'\r\n        ),\r\n\r\n        # Spawn robot in Gazebo\r\n        Node(\r\n            package='gazebo_ros',\r\n            executable='spawn_entity.py',\r\n            arguments=['-entity', 'humanoid', '-topic', 'robot_description'],\r\n            output='screen'\r\n        ),\r\n\r\n        # Publish robot description\r\n        Node(\r\n            package='robot_state_publisher',\r\n            executable='robot_state_publisher',\r\n            parameters=[{'robot_description': open(urdf_path).read()}],\r\n            output='screen'\r\n        ),\r\n\r\n        # Load and start controller manager\r\n        Node(\r\n            package='controller_manager',\r\n            executable='ros2_control_node',\r\n            parameters=[controller_config],\r\n            output='screen'\r\n        ),\r\n\r\n        # Spawn controllers\r\n        ExecuteProcess(\r\n            cmd=['ros2', 'control', 'load_controller', '--set-state', 'active',\r\n                 'joint_state_broadcaster'],\r\n            output='screen'\r\n        ),\r\n\r\n        ExecuteProcess(\r\n            cmd=['ros2', 'control', 'load_controller', '--set-state', 'active',\r\n                 'arm_trajectory_controller'],\r\n            output='screen'\r\n        ),\r\n\r\n        # Launch RViz for visualization\r\n        Node(\r\n            package='rviz2',\r\n            executable='rviz2',\r\n            arguments=['-d', os.path.join(\r\n                get_package_share_directory('humanoid_description'),\r\n                'rviz',\r\n                'humanoid.rviz'\r\n            )],\r\n            output='screen'\r\n        ),\r\n    ])\n"})}),"\n",(0,t.jsx)(e.h2,{id:"testing-controllers",children:"Testing Controllers"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:'# List available controllers\r\nros2 control list_controllers\r\n\r\n# Check controller status\r\nros2 control list_hardware_interfaces\r\n\r\n# Send position command to arm controller\r\nros2 topic pub /arm_position_controller/commands std_msgs/msg/Float64MultiArray \\\r\n  "{data: [0.5, 0.3, 1.2, -0.5, -0.3, -1.2]}"\r\n\r\n# Send trajectory to trajectory controller\r\nros2 action send_goal /arm_trajectory_controller/follow_joint_trajectory \\\r\n  control_msgs/action/FollowJointTrajectory \\\r\n  -f trajectory_goal.yaml\n'})}),"\n",(0,t.jsx)(e.h2,{id:"hardware-interfaces-for-real-robots",children:"Hardware Interfaces for Real Robots"}),"\n",(0,t.jsx)(e.p,{children:"For physical humanoid hardware, implement a custom hardware interface plugin:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include "hardware_interface/system_interface.hpp"\r\n\r\nclass HumanoidHardwareInterface : public hardware_interface::SystemInterface\r\n{\r\npublic:\r\n  // Initialize hardware (open serial ports, connect to motor controllers)\r\n  hardware_interface::CallbackReturn on_init(\r\n    const hardware_interface::HardwareInfo & info) override;\r\n\r\n  // Read joint states from encoders\r\n  hardware_interface::return_type read(\r\n    const rclcpp::Time & time, const rclcpp::Duration & period) override;\r\n\r\n  // Write commands to motors\r\n  hardware_interface::return_type write(\r\n    const rclcpp::Time & time, const rclcpp::Duration & period) override;\r\n\r\nprivate:\r\n  // Hardware communication (e.g., CAN bus, EtherCAT)\r\n  std::unique_ptr<MotorController> motor_controller_;\r\n\r\n  // Cached state/command values\r\n  std::vector<double> joint_positions_;\r\n  std::vector<double> joint_velocities_;\r\n  std::vector<double> joint_efforts_;\r\n  std::vector<double> joint_commands_;\r\n};\n'})}),"\n",(0,t.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(e.p,{children:["You now understand how ros2_control bridges simulation and hardware through standardized interfaces. The final chapter provides a ",(0,t.jsx)(e.strong,{children:"Complete URDF Example"})," with integrated ros2_control configuration\u2014a working humanoid robot ready for simulation in Gazebo."]}),"\n",(0,t.jsx)(e.h3,{id:"practice-exercise",children:"Practice Exercise"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["Modify ",(0,t.jsx)(e.code,{children:"controllers.yaml"})," to create a ",(0,t.jsx)(e.code,{children:"leg_position_controller"})," for hip and knee joints"]}),"\n",(0,t.jsx)(e.li,{children:"Launch the system in Gazebo"}),"\n",(0,t.jsxs)(e.li,{children:["Send commands to move the legs using ",(0,t.jsx)(e.code,{children:"ros2 topic pub"})]}),"\n",(0,t.jsxs)(e.li,{children:["Monitor joint states with ",(0,t.jsx)(e.code,{children:"ros2 topic echo /joint_states"})]}),"\n",(0,t.jsx)(e.li,{children:"Tune PID gains to achieve smooth motion without oscillation"}),"\n"]})]})}function m(r={}){const{wrapper:e}={...(0,i.R)(),...r.components};return e?(0,t.jsx)(e,{...r,children:(0,t.jsx)(d,{...r})}):d(r)}},8453:(r,e,n)=>{n.d(e,{R:()=>a,x:()=>s});var o=n(6540);const t={},i=o.createContext(t);function a(r){const e=o.useContext(i);return o.useMemo(function(){return"function"==typeof r?r(e):{...e,...r}},[e,r])}function s(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(t):r.components||t:a(r.components),o.createElement(i.Provider,{value:e},r.children)}}}]);