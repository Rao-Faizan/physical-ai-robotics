"use strict";(globalThis.webpackChunkphysical_ai_robotics=globalThis.webpackChunkphysical_ai_robotics||[]).push([[4502],{7135:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>m,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module-01-ros2/week-3-nodes-topics","title":"Week 3: Nodes and Topics","description":"Understanding the Publish-Subscribe Pattern","source":"@site/docs/module-01-ros2/week-3-nodes-topics.md","sourceDirName":"module-01-ros2","slug":"/module-01-ros2/week-3-nodes-topics","permalink":"/physical-ai-robotics/docs/module-01-ros2/week-3-nodes-topics","draft":false,"unlisted":false,"editUrl":"https://github.com/Rao-Faizan/physical-ai-robotics/tree/main/frontend/docs/module-01-ros2/week-3-nodes-topics.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Week 3: ROS 2 Basics","permalink":"/physical-ai-robotics/docs/module-01-ros2/week-3-basics"},"next":{"title":"Week 4: Services and Actions","permalink":"/physical-ai-robotics/docs/module-01-ros2/week-4-services-actions"}}');var s=r(4848),t=r(8453);const o={},l="Week 3: Nodes and Topics",a={},c=[{value:"Understanding the Publish-Subscribe Pattern",id:"understanding-the-publish-subscribe-pattern",level:2},{value:"Topic Characteristics",id:"topic-characteristics",level:3},{value:"Creating Python Nodes with rclpy",id:"creating-python-nodes-with-rclpy",level:2},{value:"Publisher Node: Joint Command Publisher",id:"publisher-node-joint-command-publisher",level:3},{value:"Subscriber Node: Joint State Monitor",id:"subscriber-node-joint-state-monitor",level:3},{value:"Running the Example",id:"running-the-example",level:2},{value:"Step 1: Add Nodes to Package",id:"step-1-add-nodes-to-package",level:3},{value:"Step 2: Build and Run",id:"step-2-build-and-run",level:3},{value:"TurtleSim Example: Visualizing Topics",id:"turtlesim-example-visualizing-topics",level:2},{value:"Message Types Deep Dive",id:"message-types-deep-dive",level:2},{value:"Next Steps",id:"next-steps",level:2},{value:"Practice Exercise",id:"practice-exercise",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"week-3-nodes-and-topics",children:"Week 3: Nodes and Topics"})}),"\n",(0,s.jsx)(n.h2,{id:"understanding-the-publish-subscribe-pattern",children:"Understanding the Publish-Subscribe Pattern"}),"\n",(0,s.jsx)(n.p,{children:"The publish-subscribe pattern is the backbone of ROS 2 communication. Unlike direct function calls between modules, pub-sub decouples data producers from consumers. A publisher broadcasts messages on a named topic without knowing which nodes (if any) are listening. Subscribers receive all messages on topics they're interested in, without knowing the source."}),"\n",(0,s.jsx)(n.p,{children:"For humanoid robots, this pattern is essential. Consider a balance controller that needs foot pressure data. Multiple sensors (left foot, right foot, toe pressure, heel pressure) can publish to separate topics. The balance controller subscribes to all relevant topics, processing data as it arrives\u2014without tight coupling to specific sensor implementations."}),"\n",(0,s.jsx)(n.h3,{id:"topic-characteristics",children:"Topic Characteristics"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Topics are typed"}),": Each topic has a specific message type (e.g., ",(0,s.jsx)(n.code,{children:"sensor_msgs/msg/JointState"}),"). Publishers and subscribers must agree on the type, ensuring type safety at compile time."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Topics are many-to-many"}),": Multiple publishers can write to one topic (e.g., multiple cameras publishing images). Multiple subscribers can read from one topic (e.g., both a logger and a vision algorithm consuming camera data)."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Topics are asynchronous"}),": Publishers don't wait for subscribers. If no subscribers exist, messages are discarded. This prevents blocking in time-critical control loops."]}),"\n",(0,s.jsx)(n.h2,{id:"creating-python-nodes-with-rclpy",children:"Creating Python Nodes with rclpy"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"rclpy"})," library provides Python bindings for ROS 2. Let's create a complete example: a node that publishes joint angle commands for a humanoid robot."]}),"\n",(0,s.jsx)(n.h3,{id:"publisher-node-joint-command-publisher",children:"Publisher Node: Joint Command Publisher"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"\r\nJoint command publisher for humanoid robot.\r\nPublishes target angles for shoulder, elbow, hip, and knee joints.\r\n\"\"\"\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import JointState\r\nfrom std_msgs.msg import Header\r\nimport math\r\n\r\nclass JointCommandPublisher(Node):\r\n    \"\"\"\r\n    Publishes periodic joint commands to simulate arm movement.\r\n    \"\"\"\r\n\r\n    def __init__(self):\r\n        # Initialize node with name 'joint_command_publisher'\r\n        super().__init__('joint_command_publisher')\r\n\r\n        # Create publisher on /joint_commands topic\r\n        # Queue size of 10 stores up to 10 messages if subscriber can't keep up\r\n        self.publisher_ = self.create_publisher(\r\n            JointState,\r\n            '/joint_commands',\r\n            10\r\n        )\r\n\r\n        # Create timer to publish at 10 Hz (100ms period)\r\n        # Humanoid control typically runs at 100-1000 Hz; 10 Hz is for demonstration\r\n        timer_period = 0.1  # seconds\r\n        self.timer = self.create_timer(timer_period, self.timer_callback)\r\n\r\n        # Track time for sinusoidal motion\r\n        self.time_step = 0\r\n\r\n        # Define joint names for humanoid arm (matches URDF convention)\r\n        self.joint_names = [\r\n            'left_shoulder_pitch',\r\n            'left_shoulder_roll',\r\n            'left_elbow',\r\n            'right_shoulder_pitch',\r\n            'right_shoulder_roll',\r\n            'right_elbow'\r\n        ]\r\n\r\n        self.get_logger().info('Joint command publisher started')\r\n\r\n    def timer_callback(self):\r\n        \"\"\"\r\n        Called every 100ms to publish new joint commands.\r\n        Generates sinusoidal trajectories for smooth arm motion.\r\n        \"\"\"\r\n        msg = JointState()\r\n\r\n        # Populate header with timestamp (required for sensor data)\r\n        msg.header = Header()\r\n        msg.header.stamp = self.get_clock().now().to_msg()\r\n        msg.header.frame_id = 'base_link'\r\n\r\n        # Set joint names\r\n        msg.name = self.joint_names\r\n\r\n        # Generate sinusoidal joint angles (in radians)\r\n        # Amplitude of 0.5 rad \u2248 28 degrees provides safe range of motion\r\n        msg.position = [\r\n            0.5 * math.sin(self.time_step),      # Left shoulder pitch: forward/back\r\n            0.3 * math.cos(self.time_step),      # Left shoulder roll: side to side\r\n            0.8 * math.sin(self.time_step * 2),  # Left elbow: faster bend/extend\r\n            -0.5 * math.sin(self.time_step),     # Right shoulder: opposite of left\r\n            -0.3 * math.cos(self.time_step),\r\n            -0.8 * math.sin(self.time_step * 2)\r\n        ]\r\n\r\n        # Velocity (rad/s) - typically computed from position derivatives\r\n        # For demonstration, set to zero (position control mode)\r\n        msg.velocity = [0.0] * len(self.joint_names)\r\n\r\n        # Effort (torque in Nm) - not used in position control\r\n        msg.effort = []\r\n\r\n        # Publish message\r\n        self.publisher_.publish(msg)\r\n\r\n        # Log every 1 second (10 messages)\r\n        if self.time_step % 10 < 0.1:\r\n            self.get_logger().info(f'Published joint commands at t={self.time_step:.1f}s')\r\n\r\n        # Increment time for next iteration\r\n        self.time_step += 0.1\r\n\r\ndef main(args=None):\r\n    # Initialize rclpy library\r\n    rclpy.init(args=args)\r\n\r\n    # Create node instance\r\n    node = JointCommandPublisher()\r\n\r\n    try:\r\n        # Spin node to process callbacks (runs until Ctrl+C)\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        # Graceful shutdown on Ctrl+C\r\n        node.get_logger().info('Shutting down joint command publisher')\r\n    finally:\r\n        # Clean up resources\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,s.jsx)(n.h3,{id:"subscriber-node-joint-state-monitor",children:"Subscriber Node: Joint State Monitor"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"\r\nJoint state monitor for humanoid robot.\r\nSubscribes to joint commands and logs current positions.\r\n\"\"\"\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import JointState\r\n\r\nclass JointStateMonitor(Node):\r\n    \"\"\"\r\n    Monitors joint commands and detects potential safety violations.\r\n    \"\"\"\r\n\r\n    def __init__(self):\r\n        super().__init__('joint_state_monitor')\r\n\r\n        # Create subscription to /joint_commands topic\r\n        # QoS depth of 10 matches publisher\r\n        self.subscription = self.create_subscription(\r\n            JointState,\r\n            '/joint_commands',\r\n            self.listener_callback,\r\n            10\r\n        )\r\n\r\n        # Define joint limits (radians) for safety checking\r\n        # In production, these would come from URDF or config file\r\n        self.joint_limits = {\r\n            'left_shoulder_pitch': (-1.57, 1.57),   # \xb190 degrees\r\n            'left_shoulder_roll': (-0.785, 0.785),  # \xb145 degrees\r\n            'left_elbow': (0.0, 2.356),             # 0 to 135 degrees\r\n            'right_shoulder_pitch': (-1.57, 1.57),\r\n            'right_shoulder_roll': (-0.785, 0.785),\r\n            'right_elbow': (0.0, 2.356)\r\n        }\r\n\r\n        self.get_logger().info('Joint state monitor started')\r\n\r\n    def listener_callback(self, msg):\r\n        \"\"\"\r\n        Called automatically whenever a message is published on /joint_commands.\r\n\r\n        Args:\r\n            msg (JointState): Received joint state message\r\n        \"\"\"\r\n        # Check for safety violations\r\n        for i, joint_name in enumerate(msg.name):\r\n            if joint_name in self.joint_limits:\r\n                position = msg.position[i]\r\n                min_limit, max_limit = self.joint_limits[joint_name]\r\n\r\n                if position < min_limit or position > max_limit:\r\n                    self.get_logger().warning(\r\n                        f'SAFETY: {joint_name} at {position:.3f} rad '\r\n                        f'exceeds limits [{min_limit:.3f}, {max_limit:.3f}]'\r\n                    )\r\n\r\n        # Log received data (throttled to avoid spam)\r\n        # In production, would send to data recorder or dashboard\r\n        if len(msg.position) > 0:\r\n            self.get_logger().info(\r\n                f'Received: {len(msg.position)} joints, '\r\n                f'first position: {msg.position[0]:.3f} rad'\r\n            )\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = JointStateMonitor()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info('Shutting down joint state monitor')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"running-the-example",children:"Running the Example"}),"\n",(0,s.jsx)(n.h3,{id:"step-1-add-nodes-to-package",children:"Step 1: Add Nodes to Package"}),"\n",(0,s.jsxs)(n.p,{children:["Save the publisher as ",(0,s.jsx)(n.code,{children:"humanoid_ws/src/humanoid_control/humanoid_control/joint_publisher.py"})," and the subscriber as ",(0,s.jsx)(n.code,{children:"joint_monitor.py"}),". Update ",(0,s.jsx)(n.code,{children:"setup.py"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"entry_points={\r\n    'console_scripts': [\r\n        'joint_publisher = humanoid_control.joint_publisher:main',\r\n        'joint_monitor = humanoid_control.joint_monitor:main',\r\n    ],\r\n},\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-2-build-and-run",children:"Step 2: Build and Run"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Build workspace\r\ncd ~/humanoid_ws\r\ncolcon build --symlink-install\r\nsource install/setup.bash\r\n\r\n# Terminal 1: Start publisher\r\nros2 run humanoid_control joint_publisher\r\n\r\n# Terminal 2: Start monitor (in new terminal, after sourcing)\r\nros2 run humanoid_control joint_monitor\r\n\r\n# Terminal 3: Inspect communication\r\nros2 topic hz /joint_commands  # Should show ~10 Hz\r\nros2 topic echo /joint_commands  # View raw messages\n"})}),"\n",(0,s.jsx)(n.h2,{id:"turtlesim-example-visualizing-topics",children:"TurtleSim Example: Visualizing Topics"}),"\n",(0,s.jsxs)(n.p,{children:["TurtleSim provides a visual demonstration of pub-sub communication. The turtle's position is controlled via the ",(0,s.jsx)(n.code,{children:"/turtle1/cmd_vel"})," topic."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'# Start turtlesim node\r\nros2 run turtlesim turtlesim_node\r\n\r\n# In new terminal: Publish velocity commands\r\nros2 topic pub /turtle1/cmd_vel geometry_msgs/msg/Twist \\\r\n  "{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.0}}"\r\n\r\n# Watch turtle move in circle (2 m/s forward, 1 rad/s rotation)\n'})}),"\n",(0,s.jsx)(n.p,{children:"Create a custom controller:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import Twist\r\nimport math\r\n\r\nclass TurtleCircleController(Node):\r\n    def __init__(self):\r\n        super().__init__('turtle_circle')\r\n        self.publisher_ = self.create_publisher(Twist, '/turtle1/cmd_vel', 10)\r\n        self.timer = self.create_timer(0.1, self.publish_velocity)\r\n        self.angle = 0.0\r\n\r\n    def publish_velocity(self):\r\n        msg = Twist()\r\n        # Vary linear velocity to create spiral pattern\r\n        msg.linear.x = 2.0 + math.sin(self.angle)\r\n        msg.angular.z = 1.0\r\n        self.publisher_.publish(msg)\r\n        self.angle += 0.1\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    rclpy.spin(TurtleCircleController())\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"message-types-deep-dive",children:"Message Types Deep Dive"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"sensor_msgs/msg/JointState"}),": Standard message for robot joint data"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"header"}),": Timestamp and coordinate frame"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"name[]"}),": Joint identifiers (must match URDF)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"position[]"}),": Angles (rad) or displacements (m)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"velocity[]"}),": Angular or linear velocities"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"effort[]"}),": Torques (Nm) or forces (N)"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"geometry_msgs/msg/Twist"}),": Velocity command for mobile robots"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"linear"}),": Velocity in x, y, z (m/s)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"angular"}),": Rotation around x, y, z (rad/s)"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Always check message definitions with ",(0,s.jsx)(n.code,{children:"ros2 interface show <msg_type>"})," before using."]}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.p,{children:["You now understand topic-based communication and can create publishers and subscribers. Next chapter covers ",(0,s.jsx)(n.strong,{children:"Services and Actions"}),' for request-response patterns and long-running tasks\u2014essential for high-level robot behaviors like "stand up" or "grasp object."']}),"\n",(0,s.jsx)(n.h3,{id:"practice-exercise",children:"Practice Exercise"}),"\n",(0,s.jsx)(n.p,{children:"Extend the joint monitor to compute and publish joint velocities:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Subscribe to ",(0,s.jsx)(n.code,{children:"/joint_commands"})]}),"\n",(0,s.jsx)(n.li,{children:"Calculate velocity as (current_position - previous_position) / dt"}),"\n",(0,s.jsxs)(n.li,{children:["Publish to new topic ",(0,s.jsx)(n.code,{children:"/joint_velocities"})]}),"\n",(0,s.jsxs)(n.li,{children:["Visualize with ",(0,s.jsx)(n.code,{children:"rqt_plot /joint_velocities"})]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>l});var i=r(6540);const s={},t=i.createContext(s);function o(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);