"use strict";(globalThis.webpackChunkphysical_ai_robotics=globalThis.webpackChunkphysical_ai_robotics||[]).push([[8054],{5852:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module-02-simulation/week-7-worlds","title":"Week 7: Building Custom Simulation Worlds","description":"Why Custom Environments Matter","source":"@site/docs/module-02-simulation/week-7-worlds.md","sourceDirName":"module-02-simulation","slug":"/module-02-simulation/week-7-worlds","permalink":"/physical-ai-robotics/docs/module-02-simulation/week-7-worlds","draft":false,"unlisted":false,"editUrl":"https://github.com/Rao-Faizan/physical-ai-robotics/tree/main/frontend/docs/module-02-simulation/week-7-worlds.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Week 7: Unity for Robotics","permalink":"/physical-ai-robotics/docs/module-02-simulation/week-7-unity"},"next":{"title":"Module 3: NVIDIA Isaac Platform for Physical AI","permalink":"/physical-ai-robotics/docs/module-03-isaac/intro"}}');var s=r(4848),t=r(8453);const a={},o="Week 7: Building Custom Simulation Worlds",l={},c=[{value:"Why Custom Environments Matter",id:"why-custom-environments-matter",level:2},{value:"Gazebo: Building Procedural Terrains",id:"gazebo-building-procedural-terrains",level:2},{value:"Heightmap Terrains (DEM Data)",id:"heightmap-terrains-dem-data",level:3},{value:"Obstacles and Dynamic Objects",id:"obstacles-and-dynamic-objects",level:3},{value:"Unity: Realistic Indoor/Outdoor Scenes",id:"unity-realistic-indooroutdoor-scenes",level:2},{value:"Terrain Creation in Unity",id:"terrain-creation-in-unity",level:3},{value:"Stairs and Multi-Level Structures",id:"stairs-and-multi-level-structures",level:3},{value:"Lighting for Realistic Sim-to-Real",id:"lighting-for-realistic-sim-to-real",level:3},{value:"Domain Randomization Best Practices",id:"domain-randomization-best-practices",level:2},{value:"Testing Checklist for Custom Worlds",id:"testing-checklist-for-custom-worlds",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"week-7-building-custom-simulation-worlds",children:"Week 7: Building Custom Simulation Worlds"})}),"\n",(0,s.jsx)(e.h2,{id:"why-custom-environments-matter",children:"Why Custom Environments Matter"}),"\n",(0,s.jsx)(e.p,{children:"Generic flat-ground simulations fail to expose real-world challenges:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Terrain Variability"}),": Slopes, stairs, uneven surfaces test balance controllers"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Obstacles"}),": Narrow passages, dynamic objects validate collision avoidance"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Lighting Conditions"}),": Shadows, reflections affect vision-based policies"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Domain Randomization"}),": Varying physics/visuals improves sim-to-real transfer"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Goal"}),": Create environments that challenge your robot and mirror deployment scenarios."]}),"\n",(0,s.jsx)(e.h2,{id:"gazebo-building-procedural-terrains",children:"Gazebo: Building Procedural Terrains"}),"\n",(0,s.jsx)(e.h3,{id:"heightmap-terrains-dem-data",children:"Heightmap Terrains (DEM Data)"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Heightmaps"})," use grayscale images to define terrain elevation (white=high, black=low)."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- world_with_terrain.sdf --\x3e\r\n<sdf version="1.8">\r\n  <world name="outdoor_terrain">\r\n    <physics type="bullet">\r\n      <max_step_size>0.001</max_step_size>\r\n      <real_time_factor>1.0</real_time_factor>\r\n    </physics>\r\n\r\n    \x3c!-- Heightmap terrain from image --\x3e\r\n    <model name="terrain">\r\n      <static>true</static>\r\n      <link name="terrain_link">\r\n        <collision name="terrain_collision">\r\n          <geometry>\r\n            <heightmap>\r\n              <uri>file://terrain_heightmap.png</uri> \x3c!-- 512x512 grayscale PNG --\x3e\r\n              <size>100 100 10</size> \x3c!-- Width Depth MaxHeight (meters) --\x3e\r\n              <pos>0 0 0</pos>\r\n            </heightmap>\r\n          </geometry>\r\n          <surface>\r\n            <friction>\r\n              <ode><mu>0.8</mu></ode> \x3c!-- Dirt/grass friction --\x3e\r\n            </friction>\r\n          </surface>\r\n        </collision>\r\n\r\n        <visual name="terrain_visual">\r\n          <geometry>\r\n            <heightmap>\r\n              <uri>file://terrain_heightmap.png</uri>\r\n              <size>100 100 10</size>\r\n              <texture>\r\n                <diffuse>file://grass_texture.jpg</diffuse>\r\n                <normal>file://grass_normal.jpg</normal> \x3c!-- Normal map for detail --\x3e\r\n                <size>10</size> \x3c!-- Texture repeat every 10m --\x3e\r\n              </texture>\r\n            </heightmap>\r\n          </geometry>\r\n        </visual>\r\n      </link>\r\n    </model>\r\n\r\n    \x3c!-- Dynamic lighting (sun moves over time) --\x3e\r\n    <light name="sun" type="directional">\r\n      <pose>0 0 100 0 0 0</pose>\r\n      <diffuse>0.9 0.9 0.7 1</diffuse> \x3c!-- Warm daylight --\x3e\r\n      <specular>0.2 0.2 0.2 1</specular>\r\n      <direction>-0.5 0.1 -0.9</direction> \x3c!-- Angled sunlight --\x3e\r\n      <cast_shadows>true</cast_shadows> \x3c!-- Realistic shadows --\x3e\r\n    </light>\r\n  </world>\r\n</sdf>\n'})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Generate Heightmap with Python"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'import numpy as np\r\nfrom PIL import Image\r\n\r\ndef generate_hilly_terrain(width=512, height=512, num_hills=20):\r\n    """\r\n    Create procedural hills using Gaussian blobs.\r\n    Args:\r\n        width, height: Image dimensions\r\n        num_hills: Number of random hills\r\n    Returns:\r\n        PIL Image (grayscale heightmap)\r\n    """\r\n    terrain = np.zeros((height, width), dtype=np.float32)\r\n\r\n    for _ in range(num_hills):\r\n        # Random hill center\r\n        cx = np.random.randint(0, width)\r\n        cy = np.random.randint(0, height)\r\n\r\n        # Random hill size and height\r\n        sigma = np.random.randint(20, 80)  # Width of hill\r\n        amplitude = np.random.uniform(0.3, 1.0)  # Height (0-1 scale)\r\n\r\n        # Create Gaussian hill\r\n        y, x = np.ogrid[:height, :width]\r\n        hill = amplitude * np.exp(-((x - cx)**2 + (y - cy)**2) / (2 * sigma**2))\r\n        terrain += hill\r\n\r\n    # Normalize to 0-255 (PNG grayscale range)\r\n    terrain = (terrain / terrain.max() * 255).astype(np.uint8)\r\n\r\n    # Save as PNG\r\n    img = Image.fromarray(terrain, mode=\'L\')\r\n    img.save(\'terrain_heightmap.png\')\r\n    print("Heightmap saved: terrain_heightmap.png")\r\n\r\n# Generate terrain\r\ngenerate_hilly_terrain()\n'})}),"\n",(0,s.jsx)(e.h3,{id:"obstacles-and-dynamic-objects",children:"Obstacles and Dynamic Objects"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Add dynamic obstacles (boxes that can be pushed) --\x3e\r\n<model name="obstacle_box_1">\r\n  <pose>5 3 0.5 0 0 0</pose>\r\n  <link name="box_link">\r\n    <inertial>\r\n      <mass>20.0</mass> \x3c!-- 20kg box (heavy enough to challenge robot) --\x3e\r\n      <inertia><ixx>0.67</ixx><iyy>0.67</iyy><izz>0.67</izz></inertia>\r\n    </inertial>\r\n    <collision name="box_collision">\r\n      <geometry>\r\n        <box><size>1.0 1.0 1.0</size></box>\r\n      </geometry>\r\n      <surface>\r\n        <friction><ode><mu>0.5</mu></ode></friction> \x3c!-- Cardboard on ground --\x3e\r\n      </surface>\r\n    </collision>\r\n    <visual name="box_visual">\r\n      <geometry><box><size>1.0 1.0 1.0</size></box></geometry>\r\n      <material>\r\n        <ambient>0.7 0.5 0.3 1</ambient> \x3c!-- Brown cardboard color --\x3e\r\n      </material>\r\n    </visual>\r\n  </link>\r\n</model>\r\n\r\n\x3c!-- Narrow doorway (0.8m wide - tight for humanoid) --\x3e\r\n<model name="doorway">\r\n  <static>true</static>\r\n  <pose>10 0 0 0 0 0</pose>\r\n\r\n  <link name="left_wall">\r\n    <pose>0 -2 1 0 0 0</pose>\r\n    <collision name="wall_collision">\r\n      <geometry><box><size>0.2 4 2</size></box></geometry>\r\n    </collision>\r\n    <visual name="wall_visual">\r\n      <geometry><box><size>0.2 4 2</size></box></geometry>\r\n    </visual>\r\n  </link>\r\n\r\n  <link name="right_wall">\r\n    <pose>0 2 1 0 0 0</pose>\r\n    <collision name="wall_collision">\r\n      <geometry><box><size>0.2 4 2</size></box></geometry>\r\n    </collision>\r\n    <visual name="wall_visual">\r\n      <geometry><box><size>0.2 4 2</size></box></geometry>\r\n    </visual>\r\n  </link>\r\n</model>\n'})}),"\n",(0,s.jsx)(e.h2,{id:"unity-realistic-indooroutdoor-scenes",children:"Unity: Realistic Indoor/Outdoor Scenes"}),"\n",(0,s.jsx)(e.h3,{id:"terrain-creation-in-unity",children:"Terrain Creation in Unity"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Terrain GameObject"}),": ",(0,s.jsx)(e.code,{children:"GameObject \u2192 3D Object \u2192 Terrain"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Sculpt with Brushes"}),":","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Raise/Lower"}),": Create hills and valleys"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Smooth"}),": Reduce sharp edges (important for stable foot contact)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Paint Textures"}),": Grass, dirt, gravel (multiple layers)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Programmatic Terrain Generation (C#)"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\r\n\r\npublic class ProceduralTerrain : MonoBehaviour\r\n{\r\n    public int resolution = 513; // Terrain resolution (power of 2 + 1)\r\n    public float scale = 20f;    // Perlin noise scale (larger = smoother hills)\r\n    public float heightMultiplier = 10f; // Max terrain height\r\n\r\n    void Start()\r\n    {\r\n        Terrain terrain = GetComponent<Terrain>();\r\n        TerrainData terrainData = terrain.terrainData;\r\n\r\n        // Set terrain size\r\n        terrainData.heightmapResolution = resolution;\r\n        terrainData.size = new Vector3(100, 20, 100); // Width, Height, Depth\r\n\r\n        // Generate height values using Perlin noise\r\n        float[,] heights = new float[resolution, resolution];\r\n\r\n        for (int y = 0; y < resolution; y++)\r\n        {\r\n            for (int x = 0; x < resolution; x++)\r\n            {\r\n                // Perlin noise coordinates\r\n                float xCoord = (float)x / resolution * scale;\r\n                float yCoord = (float)y / resolution * scale;\r\n\r\n                // Sample noise (0-1 range)\r\n                float height = Mathf.PerlinNoise(xCoord, yCoord);\r\n                heights[y, x] = height; // Unity uses [y, x] indexing\r\n            }\r\n        }\r\n\r\n        // Apply heights to terrain\r\n        terrainData.SetHeights(0, 0, heights);\r\n\r\n        Debug.Log("Procedural terrain generated!");\r\n    }\r\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Attach Script"}),": Add to Terrain GameObject, press Play to generate."]}),"\n",(0,s.jsx)(e.h3,{id:"stairs-and-multi-level-structures",children:"Stairs and Multi-Level Structures"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-csharp",children:'// Procedurally generate stairs (testing locomotion policies)\r\npublic class StairGenerator : MonoBehaviour\r\n{\r\n    public int numSteps = 10;\r\n    public float stepWidth = 1.0f;\r\n    public float stepDepth = 0.3f;\r\n    public float stepHeight = 0.15f; // 15cm rise (standard building code)\r\n\r\n    void Start()\r\n    {\r\n        for (int i = 0; i < numSteps; i++)\r\n        {\r\n            // Create step GameObject\r\n            GameObject step = GameObject.CreatePrimitive(PrimitiveType.Cube);\r\n            step.transform.parent = transform;\r\n\r\n            // Position step\r\n            step.transform.position = new Vector3(\r\n                0,\r\n                i * stepHeight,\r\n                i * stepDepth\r\n            );\r\n\r\n            // Scale to step dimensions\r\n            step.transform.localScale = new Vector3(stepWidth, stepHeight, stepDepth);\r\n\r\n            // Add friction (wood stairs)\r\n            var collider = step.GetComponent<BoxCollider>();\r\n            var material = new PhysicMaterial("StairMaterial");\r\n            material.dynamicFriction = 0.6f;\r\n            material.staticFriction = 0.7f;\r\n            collider.material = material;\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"lighting-for-realistic-sim-to-real",children:"Lighting for Realistic Sim-to-Real"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Key Principle"}),": Train vision policies under ",(0,s.jsx)(e.strong,{children:"varied lighting"})," to avoid overfitting to simulation conditions."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-csharp",children:"// Random lighting controller (domain randomization)\r\npublic class LightingRandomizer : MonoBehaviour\r\n{\r\n    public Light directionalLight; // Assign main sun light\r\n\r\n    void OnEpisodeBegin() // Called when RL episode resets\r\n    {\r\n        // Randomize sun angle (simulates different times of day)\r\n        float randomAngleX = Random.Range(30f, 70f); // Morning to afternoon\r\n        float randomAngleY = Random.Range(-30f, 30f); // East/West variation\r\n        directionalLight.transform.rotation = Quaternion.Euler(randomAngleX, randomAngleY, 0);\r\n\r\n        // Randomize light intensity\r\n        directionalLight.intensity = Random.Range(0.6f, 1.2f);\r\n\r\n        // Randomize color temperature (warm/cool lighting)\r\n        float colorTemp = Random.Range(0.8f, 1.0f);\r\n        directionalLight.color = new Color(1f, colorTemp, colorTemp * 0.9f);\r\n    }\r\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Additional Randomization"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Skybox"}),": Rotate to change sun position"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Fog"}),": Add atmospheric scattering (outdoor scenes)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Shadows"}),": Toggle quality (soft vs hard shadows)"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"domain-randomization-best-practices",children:"Domain Randomization Best Practices"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Physics Randomization"})," (per episode):"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Gazebo plugin to randomize physics (pseudo-code)\r\nimport random\r\n\r\nclass PhysicsRandomizer:\r\n    def on_episode_reset(self):\r\n        # Randomize gravity (\xb15%)\r\n        gravity = 9.81 * random.uniform(0.95, 1.05)\r\n\r\n        # Randomize ground friction (0.6 - 1.4)\r\n        friction = random.uniform(0.6, 1.4)\r\n\r\n        # Randomize link masses (\xb110%)\r\n        for link in robot.links:\r\n            original_mass = link.mass\r\n            link.mass = original_mass * random.uniform(0.9, 1.1)\r\n\r\n        # Randomize joint damping (\xb120%)\r\n        for joint in robot.joints:\r\n            joint.damping *= random.uniform(0.8, 1.2)\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Visual Randomization"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Material colors (RGB channels \xb130%)"}),"\n",(0,s.jsx)(e.li,{children:"Texture scales (0.5x - 2x)"}),"\n",(0,s.jsx)(e.li,{children:"Object sizes (\xb115%)"}),"\n",(0,s.jsx)(e.li,{children:"Camera exposure (\xb120%)"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Sensor Randomization"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"LiDAR noise stddev: 1-5cm"}),"\n",(0,s.jsx)(e.li,{children:"Camera latency: 10-50ms"}),"\n",(0,s.jsx)(e.li,{children:"IMU bias drift: \xb10.1 m/s\xb2"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"testing-checklist-for-custom-worlds",children:"Testing Checklist for Custom Worlds"}),"\n",(0,s.jsx)(e.p,{children:"Before training policies, verify:"}),"\n",(0,s.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Robot spawns in stable pose (not sinking/floating)"]}),"\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Collision geometry matches visual (no invisible walls)"]}),"\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Friction values are realistic (robot doesn't slip excessively)"]}),"\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Lighting doesn't cause rendering artifacts (shadow acne, z-fighting)"]}),"\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Domain randomization ranges don't break physics (e.g., negative mass)"]}),"\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Sensors receive data at expected rates (check topic frequencies)"]}),"\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Performance: Simulation runs at \u22650.5x real-time speed"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Exercise"}),": Create a Gazebo world with:"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Heightmap terrain (at least 3 hills)"}),"\n",(0,s.jsx)(e.li,{children:"Staircase (8-10 steps, 15cm rise)"}),"\n",(0,s.jsx)(e.li,{children:"3 dynamic boxes (obstacles)"}),"\n",(0,s.jsx)(e.li,{children:"Narrow corridor (0.9m wide)"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Spawn a humanoid robot and manually control it (keyboard teleop) to navigate the environment. Document which obstacles cause the robot to fall or get stuck."}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Module 2 Summary"}),": You've learned to simulate humanoid robots in Gazebo and Unity, configure realistic physics, model sensors with noise, and build challenging environments. ",(0,s.jsx)(e.strong,{children:"Next Module"}),": ",(0,s.jsx)(e.a,{href:"/physical-ai-robotics/docs/module-03-isaac/intro",children:"Isaac Sim & Gym"})," - GPU-accelerated simulation for massive parallel training."]})]})}function h(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>a,x:()=>o});var i=r(6540);const s={},t=i.createContext(s);function a(n){const e=i.useContext(t);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:a(n.components),i.createElement(t.Provider,{value:e},n.children)}}}]);