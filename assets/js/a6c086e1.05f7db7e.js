"use strict";(globalThis.webpackChunkphysical_ai_robotics=globalThis.webpackChunkphysical_ai_robotics||[]).push([[331],{1414:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"module-02-simulation/intro","title":"Module 2: Gazebo & Unity Simulation","description":"Simulation Introduction","source":"@site/docs/module-02-simulation/intro.md","sourceDirName":"module-02-simulation","slug":"/module-02-simulation/intro","permalink":"/physical-ai-robotics/docs/module-02-simulation/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/Rao-Faizan/physical-ai-robotics/tree/main/frontend/docs/module-02-simulation/intro.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Week 5: Complete Humanoid URDF Example","permalink":"/physical-ai-robotics/docs/module-01-ros2/week-5-complete-urdf"},"next":{"title":"Week 6: Gazebo Basics","permalink":"/physical-ai-robotics/docs/module-02-simulation/week-6-gazebo-basics"}}');var t=n(4848),r=n(8453);const o={},l="Module 2: Gazebo & Unity Simulation",a={},d=[{value:"Why Simulation Matters for Physical AI",id:"why-simulation-matters-for-physical-ai",level:2},{value:"The Sim-to-Real Gap",id:"the-sim-to-real-gap",level:2},{value:"Gazebo vs Unity: Choosing Your Simulator",id:"gazebo-vs-unity-choosing-your-simulator",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Module Structure",id:"module-structure",level:2}];function c(e){const i={a:"a",h1:"h1",h2:"h2",header:"header",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"module-2-gazebo--unity-simulation",children:"Module 2: Gazebo & Unity Simulation"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"Simulation Introduction",src:n(3571).A+"",width:"736",height:"736"})}),"\n",(0,t.jsx)(i.h2,{id:"why-simulation-matters-for-physical-ai",children:"Why Simulation Matters for Physical AI"}),"\n",(0,t.jsx)(i.p,{children:"Simulation is the cornerstone of modern robotics development, especially for humanoid robots. Training a physical robot through trial-and-error is expensive, time-consuming, and potentially dangerous. A single wrong movement could damage motors, break sensors, or cause the robot to fall. Simulation environments allow us to:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Accelerate Development"}),": Test thousands of scenarios in parallel without hardware limitations"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Reduce Costs"}),": Avoid physical damage to expensive robotic platforms ($50k-$500k per unit)"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Enable Safe Learning"}),": Train reinforcement learning policies without risk of injury"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Reproducible Experiments"}),": Control every environmental variable for consistent testing"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"the-sim-to-real-gap",children:"The Sim-to-Real Gap"}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.strong,{children:"sim-to-real gap"})," refers to performance degradation when transferring policies from simulation to physical hardware. Key challenges include:"]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Physics Approximation"}),": Simulators use simplified contact models and friction coefficients"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Sensor Noise"}),": Real sensors have latency, drift, and environmental interference"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Actuator Dynamics"}),": Motors exhibit backlash, compliance, and thermal effects not modeled in simulation"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Environmental Variability"}),": Real-world lighting, terrain irregularities, and air resistance differ from simulation"]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Mitigation Strategies"}),": Domain randomization (varying physics parameters), realistic sensor noise injection, system identification (measuring real robot parameters), and sim-to-real transfer techniques (like ",(0,t.jsx)(i.a,{href:"https://arxiv.org/abs/2107.04034",children:"RMA"})," - Rapid Motor Adaptation)."]}),"\n",(0,t.jsx)(i.h2,{id:"gazebo-vs-unity-choosing-your-simulator",children:"Gazebo vs Unity: Choosing Your Simulator"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"Feature"}),(0,t.jsx)(i.th,{children:"Gazebo (Classic/Ignition)"}),(0,t.jsx)(i.th,{children:"Unity with Robotics Hub"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.strong,{children:"Primary Use"})}),(0,t.jsx)(i.td,{children:"ROS2 integration, robotic research"}),(0,t.jsx)(i.td,{children:"Game development, high-fidelity graphics"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.strong,{children:"Physics Engine"})}),(0,t.jsx)(i.td,{children:"ODE, Bullet, DART, Simbody"}),(0,t.jsx)(i.td,{children:"NVIDIA PhysX, Havok"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.strong,{children:"Rendering"})}),(0,t.jsx)(i.td,{children:"OGRE (adequate)"}),(0,t.jsx)(i.td,{children:"High-quality real-time rendering"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.strong,{children:"Learning Curve"})}),(0,t.jsx)(i.td,{children:"Moderate (XML-based SDF)"}),(0,t.jsx)(i.td,{children:"Steeper (C# scripting, Unity Editor)"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.strong,{children:"ROS2 Integration"})}),(0,t.jsx)(i.td,{children:"Native support"}),(0,t.jsx)(i.td,{children:"Via Unity Robotics Hub (TCP bridge)"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.strong,{children:"Best For"})}),(0,t.jsx)(i.td,{children:"Navigation, manipulation, sensor testing"}),(0,t.jsx)(i.td,{children:"Photorealistic sim-to-real, VR training"})]})]})]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Rule of Thumb"}),": Use ",(0,t.jsx)(i.strong,{children:"Gazebo"})," for ROS2-centric development and traditional robotics workflows. Use ",(0,t.jsx)(i.strong,{children:"Unity"})," when visual fidelity matters (computer vision tasks, sim-to-real transfer for vision-based policies, or human-robot interaction studies)."]}),"\n",(0,t.jsx)(i.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,t.jsx)(i.p,{children:"By the end of this module, you will be able to:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Configure Simulation Environments"}),": Set up Gazebo and Unity for humanoid robot testing"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Model Physics Accurately"}),": Tune collision parameters, friction, and contact forces for realistic behavior"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Simulate Sensor Suites"}),": Integrate LiDAR, depth cameras, IMUs, and force-torque sensors"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Build Custom Worlds"}),": Design environments that challenge locomotion and manipulation policies"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Bridge Sim-to-Real"}),": Apply domain randomization and identify sources of simulation bias"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"module-structure",children:"Module Structure"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Week 6"}),": Gazebo fundamentals, physics engines, and sensor simulation"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Week 7"}),": Unity Robotics Hub, environment design, and sim-to-real best practices"]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Prerequisites"}),": Familiarity with ROS2 (Module 1), basic Python/C# programming, and 3D coordinate systems."]}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Next Chapter"}),": ",(0,t.jsx)(i.a,{href:"/physical-ai-robotics/docs/module-02-simulation/week-6-gazebo-basics",children:"Week 6 - Gazebo Basics"})," - Installation, SDF models, and world file creation."]})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},3571:(e,i,n)=>{n.d(i,{A:()=>s});const s=n.p+"assets/images/ai-7-f164750f333efc602ea3432d654ca348.png"},8453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>l});var s=n(6540);const t={},r=s.createContext(t);function o(e){const i=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:i},e.children)}}}]);