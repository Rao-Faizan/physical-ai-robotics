"use strict";(globalThis.webpackChunkphysical_ai_robotics=globalThis.webpackChunkphysical_ai_robotics||[]).push([[3252],{6070:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-03-isaac/week-10-bipedal-locomotion","title":"Week 10: Bipedal Locomotion Control","description":"The Bipedal Stability Challenge","source":"@site/docs/module-03-isaac/week-10-bipedal-locomotion.md","sourceDirName":"module-03-isaac","slug":"/module-03-isaac/week-10-bipedal-locomotion","permalink":"/physical-ai-robotics/docs/module-03-isaac/week-10-bipedal-locomotion","draft":false,"unlisted":false,"editUrl":"https://github.com/Rao-Faizan/physical-ai-robotics/tree/main/frontend/docs/module-03-isaac/week-10-bipedal-locomotion.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Week 10: Navigation with Nav2","permalink":"/physical-ai-robotics/docs/module-03-isaac/week-10-nav2"},"next":{"title":"Module 4: Vision-Language-Action Integration","permalink":"/physical-ai-robotics/docs/module-04-vla/intro"}}');var o=r(4848),i=r(8453);const s={},a="Week 10: Bipedal Locomotion Control",l={},c=[{value:"The Bipedal Stability Challenge",id:"the-bipedal-stability-challenge",level:2},{value:"Key Challenges",id:"key-challenges",level:3},{value:"Zero Moment Point (ZMP) Criterion",id:"zero-moment-point-zmp-criterion",level:2},{value:"Mathematical Definition",id:"mathematical-definition",level:3},{value:"Gait Generation",id:"gait-generation",level:2},{value:"Simple Gait Trajectory Generator",id:"simple-gait-trajectory-generator",level:3},{value:"Balance Control",id:"balance-control",level:2},{value:"PID Balance Controller",id:"pid-balance-controller",level:3},{value:"Integration with Nav2",id:"integration-with-nav2",level:2},{value:"Exercises",id:"exercises",level:2}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"week-10-bipedal-locomotion-control",children:"Week 10: Bipedal Locomotion Control"})}),"\n",(0,o.jsx)(n.h2,{id:"the-bipedal-stability-challenge",children:"The Bipedal Stability Challenge"}),"\n",(0,o.jsxs)(n.p,{children:["Walking on two legs is fundamentally unstable. Unlike wheeled robots with static stability (they remain upright when stopped), humanoids must ",(0,o.jsx)(n.strong,{children:"dynamically balance"})," - constantly adjusting to prevent falling."]}),"\n",(0,o.jsx)(n.h3,{id:"key-challenges",children:"Key Challenges"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Small Support Polygon"}),": Feet provide minimal contact area compared to wheeled bases"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"High Center of Mass"}),": Humanoid torso is tall, creating large toppling moments"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Underactuation"}),": Fewer actuators than degrees of freedom (cannot directly control all motion)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Phase Transitions"}),": Switching between single-leg and double-leg support is discontinuous"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"zero-moment-point-zmp-criterion",children:"Zero Moment Point (ZMP) Criterion"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.strong,{children:"Zero Moment Point"})," is the point on the ground where the sum of gravitational and inertial forces produces zero moment (torque). For stable walking, the ZMP must remain inside the ",(0,o.jsx)(n.strong,{children:"support polygon"})," (the convex hull of foot contact points)."]}),"\n",(0,o.jsx)(n.h3,{id:"mathematical-definition",children:"Mathematical Definition"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import numpy as np\r\n\r\ndef compute_zmp(robot_state):\r\n    \"\"\"\r\n    Compute Zero Moment Point from robot's state.\r\n\r\n    Args:\r\n        robot_state: Dictionary with keys:\r\n            - 'com_pos': Center of mass position [x, y, z]\r\n            - 'com_vel': Center of mass velocity [vx, vy, vz]\r\n            - 'com_acc': Center of mass acceleration [ax, ay, az]\r\n            - 'mass': Total robot mass (kg)\r\n\r\n    Returns:\r\n        zmp: [x, y] coordinates of ZMP on ground plane\r\n    \"\"\"\r\n    g = 9.81  # Gravity acceleration (m/s\xb2)\r\n\r\n    # Extract state\r\n    x, y, z = robot_state['com_pos']\r\n    vx, vy, vz = robot_state['com_vel']\r\n    ax, ay, az = robot_state['com_acc']\r\n    m = robot_state['mass']\r\n\r\n    # ZMP equations (assuming ground at z=0)\r\n    # ZMP_x = x - z * (ax + g*\u03b8_y) / (az + g)\r\n    # ZMP_y = y - z * (ay - g*\u03b8_x) / (az + g)\r\n    # Simplified for small angles:\r\n    zmp_x = x - z * ax / (az + g)\r\n    zmp_y = y - z * ay / (az + g)\r\n\r\n    return np.array([zmp_x, zmp_y])\r\n\r\ndef is_stable(zmp, support_polygon):\r\n    \"\"\"\r\n    Check if ZMP is inside support polygon.\r\n\r\n    Args:\r\n        zmp: [x, y] ZMP coordinates\r\n        support_polygon: List of [x, y] points defining foot contacts\r\n\r\n    Returns:\r\n        stable: True if ZMP inside polygon (stable)\r\n    \"\"\"\r\n    from shapely.geometry import Point, Polygon\r\n\r\n    zmp_point = Point(zmp)\r\n    support = Polygon(support_polygon)\r\n\r\n    return support.contains(zmp_point)\r\n\r\n# Example usage\r\nrobot_state = {\r\n    'com_pos': [0.0, 0.0, 0.8],      # CoM at 80cm height\r\n    'com_vel': [0.3, 0.0, 0.0],      # Walking forward at 0.3 m/s\r\n    'com_acc': [0.1, 0.0, -0.5],     # Accelerating forward\r\n    'mass': 45.0                      # 45kg humanoid\r\n}\r\n\r\nzmp = compute_zmp(robot_state)\r\nprint(f\"ZMP position: ({zmp[0]:.3f}, {zmp[1]:.3f})\")\r\n\r\n# Support polygon during single-leg stance (right foot)\r\nright_foot_polygon = [\r\n    [0.05, 0.05],   # Front-right corner\r\n    [0.05, -0.05],  # Front-left corner\r\n    [-0.05, -0.05], # Back-left corner\r\n    [-0.05, 0.05]   # Back-right corner\r\n]\r\n\r\nstable = is_stable(zmp, right_foot_polygon)\r\nprint(f\"Robot is {'STABLE' if stable else 'UNSTABLE'}\")\n"})}),"\n",(0,o.jsx)(n.h2,{id:"gait-generation",children:"Gait Generation"}),"\n",(0,o.jsxs)(n.p,{children:["A ",(0,o.jsx)(n.strong,{children:"gait"})," is a coordinated pattern of leg movements. Humanoid walking typically uses a periodic gait with four phases:"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Double Support"}),": Both feet on ground (stable but slow)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Left Swing"}),": Right foot supports, left foot moves forward"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Double Support"}),": Both feet on ground (transition)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Right Swing"}),": Left foot supports, right foot moves forward"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"simple-gait-trajectory-generator",children:"Simple Gait Trajectory Generator"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import numpy as np\r\n\r\nclass BipedGaitGenerator:\r\n    def __init__(self, step_length=0.15, step_height=0.05, step_duration=0.8):\r\n        """\r\n        Initialize bipedal gait generator.\r\n\r\n        Args:\r\n            step_length: Forward distance per step (meters)\r\n            step_height: Maximum foot lift height (meters)\r\n            step_duration: Time for one step (seconds)\r\n        """\r\n        self.step_length = step_length\r\n        self.step_height = step_height\r\n        self.step_duration = step_duration\r\n        self.double_support_ratio = 0.2  # 20% of step in double support\r\n\r\n    def generate_foot_trajectory(self, t, foot=\'left\'):\r\n        """\r\n        Generate foot trajectory for swing phase.\r\n\r\n        Args:\r\n            t: Time within current step (0 to step_duration)\r\n            foot: \'left\' or \'right\'\r\n\r\n        Returns:\r\n            foot_pos: [x, y, z] position of foot\r\n        """\r\n        # Normalize time to [0, 1]\r\n        phase = t / self.step_duration\r\n\r\n        # Double support at beginning and end of step\r\n        ds_time = self.double_support_ratio\r\n\r\n        if phase < ds_time or phase > (1 - ds_time):\r\n            # Double support - foot on ground\r\n            return self._stance_position(foot)\r\n        else:\r\n            # Swing phase - foot in air\r\n            swing_phase = (phase - ds_time) / (1 - 2*ds_time)  # Normalize to [0, 1]\r\n\r\n            # Forward motion (linear)\r\n            x = self.step_length * swing_phase\r\n\r\n            # Lateral offset (feet separated by hip width)\r\n            y = 0.1 if foot == \'left\' else -0.1\r\n\r\n            # Vertical motion (parabolic arc for smooth lift/landing)\r\n            z = 4 * self.step_height * swing_phase * (1 - swing_phase)\r\n\r\n            return np.array([x, y, z])\r\n\r\n    def _stance_position(self, foot):\r\n        """Return foot position during stance phase."""\r\n        y = 0.1 if foot == \'left\' else -0.1\r\n        return np.array([0.0, y, 0.0])\r\n\r\n    def generate_com_trajectory(self, t, num_steps):\r\n        """\r\n        Generate center of mass trajectory.\r\n        CoM shifts laterally over support foot during single support.\r\n\r\n        Args:\r\n            t: Current time\r\n            num_steps: Number of steps planned\r\n\r\n        Returns:\r\n            com_pos: [x, y, z] CoM position\r\n        """\r\n        # Forward velocity\r\n        vx = self.step_length / self.step_duration\r\n        com_x = vx * t\r\n\r\n        # Lateral shift (oscillate between left and right)\r\n        step_index = int(t / self.step_duration)\r\n        phase = (t % self.step_duration) / self.step_duration\r\n\r\n        # Shift CoM over support foot\r\n        if step_index % 2 == 0:\r\n            # Right foot support - shift CoM right\r\n            com_y = -0.05 * np.sin(np.pi * phase)\r\n        else:\r\n            # Left foot support - shift CoM left\r\n            com_y = 0.05 * np.sin(np.pi * phase)\r\n\r\n        # Constant height (simplified)\r\n        com_z = 0.8\r\n\r\n        return np.array([com_x, com_y, com_z])\r\n\r\n# Usage example\r\ngait = BipedGaitGenerator(step_length=0.15, step_height=0.05, step_duration=0.8)\r\n\r\n# Simulate one step\r\ndt = 0.01  # 100 Hz control\r\nfor t in np.arange(0, 0.8, dt):\r\n    left_foot = gait.generate_foot_trajectory(t, foot=\'left\')\r\n    right_foot = gait.generate_foot_trajectory(t, foot=\'right\')\r\n    com = gait.generate_com_trajectory(t, num_steps=5)\r\n\r\n    # In real implementation, these would be sent to inverse kinematics\r\n    # to compute joint angles\r\n    if int(t / dt) % 10 == 0:  # Print every 0.1s\r\n        print(f"t={t:.2f}s  CoM: {com}  L_foot: {left_foot}  R_foot: {right_foot}")\n'})}),"\n",(0,o.jsx)(n.h2,{id:"balance-control",children:"Balance Control"}),"\n",(0,o.jsxs)(n.p,{children:["Maintaining balance requires ",(0,o.jsx)(n.strong,{children:"real-time feedback control"})," to correct for disturbances."]}),"\n",(0,o.jsx)(n.h3,{id:"pid-balance-controller",children:"PID Balance Controller"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class ZMPBalanceController:\r\n    def __init__(self, kp=0.5, ki=0.01, kd=0.1):\r\n        """\r\n        PID controller to keep ZMP inside support polygon.\r\n\r\n        Args:\r\n            kp, ki, kd: PID gains for position, integral, derivative control\r\n        """\r\n        self.kp = kp\r\n        self.ki = ki\r\n        self.kd = kd\r\n\r\n        # Controller state\r\n        self.zmp_error_integral = np.zeros(2)\r\n        self.prev_zmp_error = np.zeros(2)\r\n\r\n    def compute_correction(self, desired_zmp, actual_zmp, dt):\r\n        """\r\n        Compute CoM acceleration correction to achieve desired ZMP.\r\n\r\n        Args:\r\n            desired_zmp: Target ZMP position [x, y]\r\n            actual_zmp: Current ZMP position [x, y]\r\n            dt: Time step (seconds)\r\n\r\n        Returns:\r\n            com_acc_correction: [ax, ay] to add to CoM acceleration\r\n        """\r\n        # ZMP error\r\n        zmp_error = desired_zmp - actual_zmp\r\n\r\n        # Update integral\r\n        self.zmp_error_integral += zmp_error * dt\r\n\r\n        # Compute derivative\r\n        zmp_error_derivative = (zmp_error - self.prev_zmp_error) / dt\r\n        self.prev_zmp_error = zmp_error\r\n\r\n        # PID control law\r\n        correction = (\r\n            self.kp * zmp_error +\r\n            self.ki * self.zmp_error_integral +\r\n            self.kd * zmp_error_derivative\r\n        )\r\n\r\n        return correction\r\n\r\n# Usage in control loop\r\ncontroller = ZMPBalanceController(kp=0.5, ki=0.01, kd=0.1)\r\n\r\n# Simulated control loop\r\ndt = 0.01\r\ndesired_zmp = np.array([0.0, 0.0])  # Keep ZMP at center of foot\r\n\r\nfor i in range(100):\r\n    # Measure current state\r\n    actual_zmp = compute_zmp(robot_state)\r\n\r\n    # Compute correction\r\n    com_acc_correction = controller.compute_correction(desired_zmp, actual_zmp, dt)\r\n\r\n    # Apply correction to CoM acceleration\r\n    robot_state[\'com_acc\'][:2] += com_acc_correction\r\n\r\n    # Update robot state (simplified dynamics)\r\n    robot_state[\'com_vel\'] += robot_state[\'com_acc\'] * dt\r\n    robot_state[\'com_pos\'] += robot_state[\'com_vel\'] * dt\r\n\r\n    if i % 10 == 0:\r\n        print(f"ZMP error: {np.linalg.norm(desired_zmp - actual_zmp):.4f}m")\n'})}),"\n",(0,o.jsx)(n.h2,{id:"integration-with-nav2",children:"Integration with Nav2"}),"\n",(0,o.jsxs)(n.p,{children:["Connecting bipedal locomotion to Nav2 navigation requires a ",(0,o.jsx)(n.strong,{children:"velocity command interpreter"})," that converts Nav2's commanded velocities into gait parameters:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import Twist\r\nfrom std_msgs.msg import Float64MultiArray\r\n\r\nclass BipedalLocomotionNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'bipedal_locomotion\')\r\n\r\n        # Subscribe to Nav2 velocity commands\r\n        self.cmd_vel_sub = self.create_subscription(\r\n            Twist,\r\n            \'/cmd_vel\',\r\n            self.velocity_callback,\r\n            10\r\n        )\r\n\r\n        # Publish joint commands to robot\r\n        self.joint_pub = self.create_publisher(\r\n            Float64MultiArray,\r\n            \'/joint_commands\',\r\n            10\r\n        )\r\n\r\n        # Gait generator\r\n        self.gait = BipedGaitGenerator()\r\n        self.controller = ZMPBalanceController()\r\n\r\n        # Control loop at 100 Hz\r\n        self.timer = self.create_timer(0.01, self.control_loop)\r\n\r\n        self.target_vx = 0.0\r\n        self.target_vy = 0.0\r\n        self.target_omega = 0.0\r\n        self.time = 0.0\r\n\r\n    def velocity_callback(self, msg):\r\n        """Receive velocity commands from Nav2."""\r\n        self.target_vx = msg.linear.x\r\n        self.target_vy = msg.linear.y\r\n        self.target_omega = msg.angular.z\r\n\r\n        # Adjust gait parameters based on commanded velocity\r\n        self.gait.step_length = self.target_vx * self.gait.step_duration\r\n        self.gait.step_length = np.clip(self.gait.step_length, 0.0, 0.3)  # Max 30cm steps\r\n\r\n    def control_loop(self):\r\n        """Generate gait and balance control at 100 Hz."""\r\n        # Generate desired foot and CoM positions\r\n        left_foot = self.gait.generate_foot_trajectory(self.time, \'left\')\r\n        right_foot = self.gait.generate_foot_trajectory(self.time, \'right\')\r\n        com_ref = self.gait.generate_com_trajectory(self.time, num_steps=5)\r\n\r\n        # Balance control (simplified - real implementation needs full state)\r\n        desired_zmp = np.array([0.0, 0.0])  # Center of support foot\r\n        actual_zmp = np.array([0.0, 0.0])   # Would come from sensors\r\n        com_correction = self.controller.compute_correction(desired_zmp, actual_zmp, 0.01)\r\n\r\n        # TODO: Inverse kinematics to convert foot/CoM positions to joint angles\r\n        # joint_angles = inverse_kinematics(left_foot, right_foot, com_ref)\r\n\r\n        # Publish joint commands\r\n        # joint_msg = Float64MultiArray(data=joint_angles)\r\n        # self.joint_pub.publish(joint_msg)\r\n\r\n        self.time += 0.01\r\n\r\ndef main():\r\n    rclpy.init()\r\n    node = BipedalLocomotionNode()\r\n    rclpy.spin(node)\r\n    node.destroy_node()\r\n    rclpy.shutdown()\n'})}),"\n",(0,o.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"ZMP Analysis"}),": Compute ZMP for a stationary humanoid with CoM at various lateral positions. Identify the stability boundary."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Gait Visualization"}),": Use matplotlib to plot foot and CoM trajectories over 5 steps. Verify that CoM shifts appropriately over support foot."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"PID Tuning"}),": Implement the ZMP balance controller and tune PID gains to minimize settling time while avoiding oscillations."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Nav2 Integration"}),": Connect your gait generator to Nav2 velocity commands. Test navigation to waypoints in simulation."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Congratulations!"})," You've completed Module 3: NVIDIA Isaac Platform. You now understand GPU-accelerated simulation, synthetic data generation, hardware-accelerated perception, and bipedal locomotion control - the core technologies enabling next-generation humanoid robots."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Next Module"}),": ",(0,o.jsx)(n.a,{href:"/physical-ai-robotics/docs/module-04-vla/intro",children:"Module 4 - Vision-Language-Action Models"})]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>a});var t=r(6540);const o={},i=t.createContext(o);function s(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);