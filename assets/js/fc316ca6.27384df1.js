"use strict";(globalThis.webpackChunkphysical_ai_robotics=globalThis.webpackChunkphysical_ai_robotics||[]).push([[5186],{3856:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>t,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"module-03-isaac/week-10-nav2","title":"Week 10: Navigation with Nav2","description":"Navigation with Nav2","source":"@site/docs/module-03-isaac/week-10-nav2.md","sourceDirName":"module-03-isaac","slug":"/module-03-isaac/week-10-nav2","permalink":"/physical-ai-robotics/docs/module-03-isaac/week-10-nav2","draft":false,"unlisted":false,"editUrl":"https://github.com/Rao-Faizan/physical-ai-robotics/tree/main/frontend/docs/module-03-isaac/week-10-nav2.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Week 9: Perception for Manipulation","permalink":"/physical-ai-robotics/docs/module-03-isaac/week-9-perception"},"next":{"title":"Week 10: Bipedal Locomotion Control","permalink":"/physical-ai-robotics/docs/module-03-isaac/week-10-bipedal-locomotion"}}');var o=r(4848),i=r(8453);const t={},s="Week 10: Navigation with Nav2",l={},c=[{value:"Introduction to Nav2",id:"introduction-to-nav2",level:2},{value:"Nav2 Architecture",id:"nav2-architecture",level:2},{value:"Costmaps for Humanoid Navigation",id:"costmaps-for-humanoid-navigation",level:2},{value:"Key Differences from Wheeled Robots",id:"key-differences-from-wheeled-robots",level:3},{value:"Humanoid Costmap Configuration",id:"humanoid-costmap-configuration",level:3},{value:"Path Planning Algorithms",id:"path-planning-algorithms",level:2},{value:"Dijkstra vs. A*",id:"dijkstra-vs-a",level:3},{value:"Planner Configuration",id:"planner-configuration",level:3},{value:"Controller for Bipedal Motion",id:"controller-for-bipedal-motion",level:2},{value:"Bipedal-Specific Constraints",id:"bipedal-specific-constraints",level:3},{value:"Recovery Behaviors",id:"recovery-behaviors",level:2},{value:"Humanoid-Safe Recovery Sequence",id:"humanoid-safe-recovery-sequence",level:3},{value:"Launching Nav2 for Humanoid",id:"launching-nav2-for-humanoid",level:2},{value:"Exercises",id:"exercises",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"week-10-navigation-with-nav2",children:"Week 10: Navigation with Nav2"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Navigation with Nav2",src:r(6904).A+"",width:"736",height:"1313"})}),"\n",(0,o.jsx)(n.h2,{id:"introduction-to-nav2",children:"Introduction to Nav2"}),"\n",(0,o.jsxs)(n.p,{children:["Nav2 (Navigation2) is the ROS 2 navigation stack that enables autonomous robot movement. Originally designed for wheeled robots, Nav2 can be adapted for ",(0,o.jsx)(n.strong,{children:"bipedal humanoid navigation"})," with appropriate configuration."]}),"\n",(0,o.jsx)(n.h2,{id:"nav2-architecture",children:"Nav2 Architecture"}),"\n",(0,o.jsx)(n.p,{children:"Nav2 consists of modular components (servers) that work together:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Map Server"}),": Provides occupancy grid map (free space vs. obstacles)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"AMCL"}),": Adaptive Monte Carlo Localization for pose estimation"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Planner Server"}),": Computes global path from start to goal"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Controller Server"}),": Generates velocity commands to follow the path"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Recovery Server"}),": Executes behaviors when navigation fails (spinning, backing up)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Behavior Tree Navigator"}),": Orchestrates the above components"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"# Conceptual Nav2 pipeline\r\ndef navigate_to_goal(goal_pose):\r\n    # 1. Localize robot on map\r\n    current_pose = amcl.get_pose()\r\n\r\n    # 2. Plan global path\r\n    global_path = planner.make_plan(current_pose, goal_pose)\r\n\r\n    # 3. Follow path with local planning\r\n    while not at_goal:\r\n        local_plan = controller.compute_velocity_commands(global_path, current_pose)\r\n        robot.execute_velocity(local_plan)\r\n\r\n        # Handle obstacles\r\n        if path_blocked:\r\n            recovery.execute_recovery()\n"})}),"\n",(0,o.jsx)(n.h2,{id:"costmaps-for-humanoid-navigation",children:"Costmaps for Humanoid Navigation"}),"\n",(0,o.jsx)(n.p,{children:"Costmaps represent the environment as a grid where each cell has a cost (0 = free, 255 = obstacle). Humanoids require special considerations:"}),"\n",(0,o.jsx)(n.h3,{id:"key-differences-from-wheeled-robots",children:"Key Differences from Wheeled Robots"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Footprint Shape"}),": Rectangular footprint representing bipedal stance width"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Inflation Radius"}),": Smaller due to humanoid's ability to navigate tight spaces"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Height Clearance"}),": Must account for humanoid's tall vertical profile"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Dynamic Stability"}),": Cannot stop instantly - requires forward motion planning"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"humanoid-costmap-configuration",children:"Humanoid Costmap Configuration"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:'# costmap_params.yaml - Configured for bipedal humanoid\r\nglobal_costmap:\r\n  global_frame: map\r\n  robot_base_frame: base_link\r\n  update_frequency: 5.0      # Hz - update global costmap\r\n  publish_frequency: 2.0\r\n\r\n  # Costmap size\r\n  width: 20                  # 20 meter x 20 meter map\r\n  height: 20\r\n  resolution: 0.05           # 5cm grid cells\r\n\r\n  # Humanoid footprint (30cm wide stance, 50cm long including step)\r\n  footprint: [\r\n    [0.25, 0.15],   # Front-right\r\n    [0.25, -0.15],  # Front-left\r\n    [-0.25, -0.15], # Back-left\r\n    [-0.25, 0.15]   # Back-right\r\n  ]\r\n\r\n  plugins: ["static_layer", "obstacle_layer", "inflation_layer"]\r\n\r\n  static_layer:\r\n    plugin: "nav2_costmap_2d::StaticLayer"\r\n    map_subscribe_transient_local: True\r\n\r\n  obstacle_layer:\r\n    plugin: "nav2_costmap_2d::ObstacleLayer"\r\n    observation_sources: scan lidar\r\n\r\n    # Use 2D lidar for ground-level obstacles\r\n    scan:\r\n      topic: /scan\r\n      max_obstacle_height: 2.0  # Detect obstacles up to 2m (humanoid height)\r\n      clearing_range: 5.0\r\n      raytrace_range: 6.0\r\n\r\n    # Use 3D lidar/camera for full environment perception\r\n    lidar:\r\n      topic: /points\r\n      max_obstacle_height: 2.5\r\n      min_obstacle_height: 0.1  # Ignore ground\r\n\r\n  inflation_layer:\r\n    plugin: "nav2_costmap_2d::InflationLayer"\r\n    cost_scaling_factor: 3.0\r\n    inflation_radius: 0.35  # Smaller than wheeled (humanoid agility)\r\n\r\n# Local costmap for dynamic obstacle avoidance\r\nlocal_costmap:\r\n  global_frame: odom\r\n  robot_base_frame: base_link\r\n  update_frequency: 10.0     # Higher update rate for reactive navigation\r\n  publish_frequency: 5.0\r\n\r\n  width: 5                   # 5m x 5m local window\r\n  height: 5\r\n  resolution: 0.05\r\n\r\n  footprint: [\r\n    [0.25, 0.15],\r\n    [0.25, -0.15],\r\n    [-0.25, -0.15],\r\n    [-0.25, 0.15]\r\n  ]\r\n\r\n  plugins: ["voxel_layer", "inflation_layer"]\r\n\r\n  voxel_layer:\r\n    plugin: "nav2_costmap_2d::VoxelLayer"\r\n    enabled: True\r\n    publish_voxel_map: True\r\n    origin_z: 0.0\r\n    z_resolution: 0.2        # 20cm vertical resolution\r\n    z_voxels: 10             # 2m height (10 * 0.2m)\r\n    max_obstacle_height: 2.0\r\n    mark_threshold: 2        # Cells with 2+ hits marked as obstacle\n'})}),"\n",(0,o.jsx)(n.h2,{id:"path-planning-algorithms",children:"Path Planning Algorithms"}),"\n",(0,o.jsxs)(n.p,{children:["Nav2 supports multiple global planners. Humanoids benefit from ",(0,o.jsx)(n.strong,{children:"Dijkstra"})," or ",(0,o.jsx)(n.strong,{children:"A"}),"* for stable, predictable paths."]}),"\n",(0,o.jsx)(n.h3,{id:"dijkstra-vs-a",children:"Dijkstra vs. A*"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"# Dijkstra: explores uniformly in all directions\r\ndef dijkstra(start, goal, costmap):\r\n    visited = set()\r\n    priority_queue = [(0, start)]  # (cost, node)\r\n\r\n    while priority_queue:\r\n        cost, current = heappop(priority_queue)\r\n        if current == goal:\r\n            return reconstruct_path(current)\r\n\r\n        for neighbor in get_neighbors(current, costmap):\r\n            new_cost = cost + costmap[neighbor]\r\n            if neighbor not in visited:\r\n                visited.add(neighbor)\r\n                heappush(priority_queue, (new_cost, neighbor))\r\n\r\n# A*: uses heuristic to guide search toward goal\r\ndef a_star(start, goal, costmap):\r\n    visited = set()\r\n    priority_queue = [(heuristic(start, goal), 0, start)]  # (f, g, node)\r\n\r\n    while priority_queue:\r\n        f, g, current = heappop(priority_queue)\r\n        if current == goal:\r\n            return reconstruct_path(current)\r\n\r\n        for neighbor in get_neighbors(current, costmap):\r\n            new_g = g + costmap[neighbor]\r\n            new_f = new_g + heuristic(neighbor, goal)  # f = g + h\r\n            if neighbor not in visited:\r\n                visited.add(neighbor)\r\n                heappush(priority_queue, (new_f, new_g, neighbor))\r\n\r\ndef heuristic(node, goal):\r\n    # Euclidean distance as heuristic\r\n    return sqrt((node.x - goal.x)**2 + (node.y - goal.y)**2)\n"})}),"\n",(0,o.jsx)(n.h3,{id:"planner-configuration",children:"Planner Configuration"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:'# planner_server_params.yaml\r\nplanner_server:\r\n  ros__parameters:\r\n    expected_planner_frequency: 2.0  # Plan every 0.5s\r\n\r\n    plugins: ["GridBased"]\r\n\r\n    GridBased:\r\n      plugin: "nav2_navfn_planner/NavfnPlanner"  # A* implementation\r\n      tolerance: 0.1              # 10cm goal tolerance\r\n      use_astar: True             # Use A* (False = Dijkstra)\r\n      allow_unknown: False        # Don\'t plan through unexplored areas\r\n      use_final_approach_orientation: True  # Orient toward goal\n'})}),"\n",(0,o.jsx)(n.h2,{id:"controller-for-bipedal-motion",children:"Controller for Bipedal Motion"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.strong,{children:"DWB (Dynamic Window Approach) controller"})," generates velocity commands that respect kinodynamic constraints."]}),"\n",(0,o.jsx)(n.h3,{id:"bipedal-specific-constraints",children:"Bipedal-Specific Constraints"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:'# controller_params.yaml\r\ncontroller_server:\r\n  ros__parameters:\r\n    controller_frequency: 20.0  # 20 Hz control loop\r\n\r\n    plugins: ["FollowPath"]\r\n\r\n    FollowPath:\r\n      plugin: "dwb_core::DWBLocalPlanner"\r\n\r\n      # Bipedal velocity limits (slower than wheeled robots)\r\n      min_vel_x: 0.1            # Must maintain forward motion for stability\r\n      max_vel_x: 0.5            # 0.5 m/s max walking speed\r\n      min_vel_y: -0.2           # Limited lateral movement\r\n      max_vel_y: 0.2\r\n      max_vel_theta: 0.3        # 0.3 rad/s turning speed\r\n\r\n      # Acceleration limits (gradual for balance)\r\n      acc_lim_x: 0.3            # 0.3 m/s\xb2 (gentle acceleration)\r\n      acc_lim_y: 0.2\r\n      acc_lim_theta: 0.5\r\n      decel_lim_x: -0.3         # Gentle deceleration\r\n\r\n      # Trajectory scoring\r\n      critics: [\r\n        "RotateToGoal",\r\n        "Oscillation",\r\n        "BaseObstacle",\r\n        "GoalAlign",\r\n        "PathAlign",\r\n        "PathDist",\r\n        "GoalDist"\r\n      ]\r\n\r\n      # Critic weights (tune for humanoid behavior)\r\n      PathAlign.scale: 32.0      # Strongly prefer following global path\r\n      GoalAlign.scale: 24.0      # Orient toward goal\r\n      PathDist.scale: 32.0\r\n      GoalDist.scale: 24.0\r\n      BaseObstacle.scale: 0.02   # Obstacle avoidance\r\n\r\n      # Simulation parameters\r\n      sim_time: 2.0              # Simulate trajectories 2 seconds ahead\r\n      vx_samples: 10             # Sample 10 velocities per dimension\r\n      vy_samples: 5\r\n      vtheta_samples: 10\r\n\r\n      # Trajectory constraints\r\n      trajectory_generator_name: "dwb_plugins::StandardTrajectoryGenerator"\n'})}),"\n",(0,o.jsx)(n.h2,{id:"recovery-behaviors",children:"Recovery Behaviors"}),"\n",(0,o.jsx)(n.p,{children:"When navigation fails, recovery behaviors attempt to get the robot unstuck."}),"\n",(0,o.jsx)(n.h3,{id:"humanoid-safe-recovery-sequence",children:"Humanoid-Safe Recovery Sequence"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:'# behavior_tree_params.yaml\r\nbt_navigator:\r\n  ros__parameters:\r\n    plugin_lib_names:\r\n      - nav2_compute_path_to_pose_action_bt_node\r\n      - nav2_follow_path_action_bt_node\r\n      - nav2_back_up_action_bt_node\r\n      - nav2_spin_action_bt_node\r\n      - nav2_wait_action_bt_node\r\n\r\n    # Recovery behavior parameters\r\n    global_frame: map\r\n    robot_base_frame: base_link\r\n    transform_tolerance: 0.1\r\n\r\n    # Recovery sequence for humanoids (gentle, stable motions)\r\n    default_nav_through_poses_bt_xml: ""\r\n    default_nav_to_pose_bt_xml: ""\r\n\r\n    # Spin recovery - rotate in place to clear sensors\r\n    spin:\r\n      simulate_ahead_time: 2.0\r\n      max_rotational_vel: 0.2     # Slow rotation for stability\r\n      min_rotational_vel: 0.1\r\n      rotational_acc_lim: 0.3\r\n\r\n    # Backup recovery - step backward\r\n    backup:\r\n      simulate_ahead_time: 2.0\r\n      backup_dist: 0.3            # Small 30cm backup\r\n      backup_speed: 0.1           # Slow, controlled\n'})}),"\n",(0,o.jsx)(n.h2,{id:"launching-nav2-for-humanoid",children:"Launching Nav2 for Humanoid"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"# humanoid_nav2_launch.py\r\nfrom launch import LaunchDescription\r\nfrom launch_ros.actions import Node\r\nfrom ament_index_python.packages import get_package_share_directory\r\nimport os\r\n\r\ndef generate_launch_description():\r\n    pkg_dir = get_package_share_directory('humanoid_navigation')\r\n\r\n    return LaunchDescription([\r\n        # Map server - load pre-built map\r\n        Node(\r\n            package='nav2_map_server',\r\n            executable='map_server',\r\n            name='map_server',\r\n            parameters=[{\r\n                'yaml_filename': os.path.join(pkg_dir, 'maps', 'office.yaml'),\r\n                'use_sim_time': False\r\n            }]\r\n        ),\r\n\r\n        # AMCL localization\r\n        Node(\r\n            package='nav2_amcl',\r\n            executable='amcl',\r\n            name='amcl',\r\n            parameters=[os.path.join(pkg_dir, 'config', 'amcl_params.yaml')]\r\n        ),\r\n\r\n        # Planner server\r\n        Node(\r\n            package='nav2_planner',\r\n            executable='planner_server',\r\n            name='planner_server',\r\n            parameters=[os.path.join(pkg_dir, 'config', 'planner_params.yaml')]\r\n        ),\r\n\r\n        # Controller server\r\n        Node(\r\n            package='nav2_controller',\r\n            executable='controller_server',\r\n            name='controller_server',\r\n            parameters=[os.path.join(pkg_dir, 'config', 'controller_params.yaml')]\r\n        ),\r\n\r\n        # Recovery server\r\n        Node(\r\n            package='nav2_recoveries',\r\n            executable='recoveries_server',\r\n            name='recoveries_server',\r\n            parameters=[os.path.join(pkg_dir, 'config', 'recovery_params.yaml')]\r\n        ),\r\n\r\n        # Behavior tree navigator\r\n        Node(\r\n            package='nav2_bt_navigator',\r\n            executable='bt_navigator',\r\n            name='bt_navigator',\r\n            parameters=[os.path.join(pkg_dir, 'config', 'bt_navigator_params.yaml')]\r\n        ),\r\n\r\n        # Lifecycle manager\r\n        Node(\r\n            package='nav2_lifecycle_manager',\r\n            executable='lifecycle_manager',\r\n            name='lifecycle_manager_navigation',\r\n            parameters=[{\r\n                'autostart': True,\r\n                'node_names': [\r\n                    'map_server',\r\n                    'amcl',\r\n                    'planner_server',\r\n                    'controller_server',\r\n                    'recoveries_server',\r\n                    'bt_navigator'\r\n                ]\r\n            }]\r\n        )\r\n    ])\n"})}),"\n",(0,o.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Costmap Tuning"}),": Adjust footprint and inflation radius for your simulated humanoid. Observe effects on path planning."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Algorithm Comparison"}),": Run navigation with Dijkstra and A* planners. Measure planning time and path length differences."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Recovery Testing"}),": Place the robot in a tight corner and trigger recovery behaviors. Observe which sequence successfully escapes."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Dynamic Obstacles"}),": Add moving obstacles to the environment and observe local planner's avoidance behavior."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Next"}),": ",(0,o.jsx)(n.a,{href:"/physical-ai-robotics/docs/module-03-isaac/week-10-bipedal-locomotion",children:"Week 10 - Bipedal Locomotion"})]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},6904:(e,n,r)=>{r.d(n,{A:()=>a});const a=r.p+"assets/images/ai-11-71168c92bad60825ac497d00716b9fa3.png"},8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>s});var a=r(6540);const o={},i=a.createContext(o);function t(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);