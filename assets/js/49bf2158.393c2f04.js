"use strict";(globalThis.webpackChunkphysical_ai_robotics=globalThis.webpackChunkphysical_ai_robotics||[]).push([[206],{3450:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-01-ros2/week-4-services-actions","title":"Week 4: Services and Actions","description":"Services and Actions","source":"@site/docs/module-01-ros2/week-4-services-actions.md","sourceDirName":"module-01-ros2","slug":"/module-01-ros2/week-4-services-actions","permalink":"/physical-ai-robotics/docs/module-01-ros2/week-4-services-actions","draft":false,"unlisted":false,"editUrl":"https://github.com/Rao-Faizan/physical-ai-robotics/tree/main/frontend/docs/module-01-ros2/week-4-services-actions.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Week 3: Nodes and Topics","permalink":"/physical-ai-robotics/docs/module-01-ros2/week-3-nodes-topics"},"next":{"title":"Week 5: URDF for Humanoid Robots","permalink":"/physical-ai-robotics/docs/module-01-ros2/week-5-urdf"}}');var t=n(4848),a=n(8453);const i={},o="Week 4: Services and Actions",l={},c=[{value:"Service Client-Server Pattern",id:"service-client-server-pattern",level:2},{value:"When to Use Services",id:"when-to-use-services",level:3},{value:"Service Type Anatomy",id:"service-type-anatomy",level:3},{value:"Service Server Example: Inverse Kinematics Calculator",id:"service-server-example-inverse-kinematics-calculator",level:2},{value:"Service Client Example",id:"service-client-example",level:2},{value:"Action Servers: Long-Running Tasks",id:"action-servers-long-running-tasks",level:2},{value:"Action Structure",id:"action-structure",level:3},{value:"Action Server Example: Walk to Position",id:"action-server-example-walk-to-position",level:2},{value:"Parameters and Dynamic Reconfigure",id:"parameters-and-dynamic-reconfigure",level:2},{value:"Using Parameters from CLI",id:"using-parameters-from-cli",level:3},{value:"Next Steps",id:"next-steps",level:2},{value:"Practice Exercise",id:"practice-exercise",level:3}];function d(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"week-4-services-and-actions",children:"Week 4: Services and Actions"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.img,{alt:"Services and Actions",src:n(5818).A+"",width:"736",height:"736"})}),"\n",(0,t.jsx)(r.h2,{id:"service-client-server-pattern",children:"Service Client-Server Pattern"}),"\n",(0,t.jsx)(r.p,{children:"While topics enable continuous data streaming, many robot operations require request-response interactions. Services provide synchronous RPC (Remote Procedure Call) semantics: a client sends a request and blocks until receiving a response from the server."}),"\n",(0,t.jsx)(r.h3,{id:"when-to-use-services",children:"When to Use Services"}),"\n",(0,t.jsx)(r.p,{children:"Services are ideal for:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Infrequent queries"}),": Computing inverse kinematics for a target pose"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Configuration changes"}),": Setting controller gains or switching operational modes"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"State queries"}),": Requesting current battery level or system diagnostics"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Atomic operations"}),": Triggering calibration sequences that must complete before returning"]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Critical distinction"}),": Services block the calling node until complete. Never use services for operations that take more than ~1 second\u2014use actions instead (covered below)."]}),"\n",(0,t.jsx)(r.h3,{id:"service-type-anatomy",children:"Service Type Anatomy"}),"\n",(0,t.jsxs)(r.p,{children:["Services consist of a request message and a response message. Example: ",(0,t.jsx)(r.code,{children:"AddTwoInts.srv"})]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"# Request\r\nint64 a\r\nint64 b\r\n---\r\n# Response\r\nint64 sum\n"})}),"\n",(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(r.code,{children:"---"})," separator divides request from response. For humanoid robotics, common service types include:"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"SetBool"}),": Enable/disable a controller"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"Trigger"}),": Initiate calibration or homing"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"GetPose"}),": Query end-effector position"]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"service-server-example-inverse-kinematics-calculator",children:"Service Server Example: Inverse Kinematics Calculator"}),"\n",(0,t.jsx)(r.p,{children:"This server computes joint angles needed to position a humanoid's hand at a target location\u2014a fundamental operation for manipulation tasks."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"\r\nInverse kinematics service for humanoid arm.\r\nComputes joint angles to reach target end-effector pose.\r\n\"\"\"\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.srv import GetPlan\r\nfrom geometry_msgs.msg import Pose, Point, Quaternion\r\nfrom sensor_msgs.msg import JointState\r\nimport math\r\n\r\nclass IKService(Node):\r\n    \"\"\"\r\n    Provides inverse kinematics solving as a service.\r\n    Simplified 2-DOF arm for demonstration.\r\n    \"\"\"\r\n\r\n    def __init__(self):\r\n        super().__init__('ik_service')\r\n\r\n        # Create service server on /compute_ik topic\r\n        # Service type: custom message defined in package\r\n        self.srv = self.create_service(\r\n            GetPlan,  # Reusing existing type for demonstration\r\n            'compute_ik',\r\n            self.compute_ik_callback\r\n        )\r\n\r\n        # Arm parameters (meters)\r\n        self.upper_arm_length = 0.3  # Shoulder to elbow\r\n        self.forearm_length = 0.25   # Elbow to wrist\r\n\r\n        self.get_logger().info('IK service ready')\r\n\r\n    def compute_ik_callback(self, request, response):\r\n        \"\"\"\r\n        Solve inverse kinematics for 2-DOF planar arm.\r\n\r\n        Args:\r\n            request: Contains target pose (position and orientation)\r\n            response: Populated with joint angles\r\n\r\n        Returns:\r\n            response: Modified response object (ROS 2 convention)\r\n        \"\"\"\r\n        # Extract target position from request\r\n        target_x = request.goal.pose.position.x\r\n        target_y = request.goal.pose.position.y\r\n\r\n        self.get_logger().info(f'IK request: target=({target_x:.3f}, {target_y:.3f})')\r\n\r\n        # Calculate distance to target\r\n        distance = math.sqrt(target_x**2 + target_y**2)\r\n\r\n        # Check if target is reachable\r\n        max_reach = self.upper_arm_length + self.forearm_length\r\n        min_reach = abs(self.upper_arm_length - self.forearm_length)\r\n\r\n        if distance > max_reach or distance < min_reach:\r\n            self.get_logger().error(\r\n                f'Target unreachable: distance={distance:.3f}m, '\r\n                f'valid range=[{min_reach:.3f}, {max_reach:.3f}]'\r\n            )\r\n            # Return empty response to indicate failure\r\n            return response\r\n\r\n        # Compute elbow angle using law of cosines\r\n        # c\xb2 = a\xb2 + b\xb2 - 2ab*cos(C)\r\n        cos_elbow = (\r\n            (target_x**2 + target_y**2 -\r\n             self.upper_arm_length**2 - self.forearm_length**2) /\r\n            (2 * self.upper_arm_length * self.forearm_length)\r\n        )\r\n\r\n        # Clamp to [-1, 1] to avoid numerical errors\r\n        cos_elbow = max(-1.0, min(1.0, cos_elbow))\r\n        elbow_angle = math.acos(cos_elbow)\r\n\r\n        # Compute shoulder angle\r\n        alpha = math.atan2(target_y, target_x)\r\n        beta = math.atan2(\r\n            self.forearm_length * math.sin(elbow_angle),\r\n            self.upper_arm_length + self.forearm_length * math.cos(elbow_angle)\r\n        )\r\n        shoulder_angle = alpha - beta\r\n\r\n        # Populate response (in production, return JointState message)\r\n        self.get_logger().info(\r\n            f'IK solution: shoulder={math.degrees(shoulder_angle):.1f}\xb0, '\r\n            f'elbow={math.degrees(elbow_angle):.1f}\xb0'\r\n        )\r\n\r\n        # For demonstration, encode angles in response\r\n        # In real implementation, define custom service type with JointState response\r\n        response.plan.poses = []  # Placeholder\r\n\r\n        return response\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = IKService()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info('Shutting down IK service')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsx)(r.h2,{id:"service-client-example",children:"Service Client Example"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""\r\nClient that requests inverse kinematics solutions.\r\n"""\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.srv import GetPlan\r\nfrom geometry_msgs.msg import PoseStamped, Point\r\n\r\nclass IKClient(Node):\r\n    def __init__(self):\r\n        super().__init__(\'ik_client\')\r\n\r\n        # Create service client\r\n        self.client = self.create_client(GetPlan, \'compute_ik\')\r\n\r\n        # Wait for service to become available (with 5 second timeout)\r\n        self.get_logger().info(\'Waiting for IK service...\')\r\n        if not self.client.wait_for_service(timeout_sec=5.0):\r\n            self.get_logger().error(\'IK service not available\')\r\n            return\r\n\r\n        self.get_logger().info(\'IK service connected\')\r\n\r\n    def send_request(self, x, y):\r\n        """\r\n        Send IK request for target position.\r\n\r\n        Args:\r\n            x (float): Target x coordinate (meters)\r\n            y (float): Target y coordinate (meters)\r\n        """\r\n        # Create request message\r\n        request = GetPlan.Request()\r\n        request.goal = PoseStamped()\r\n        request.goal.pose.position = Point(x=x, y=y, z=0.0)\r\n\r\n        # Send request asynchronously (non-blocking)\r\n        future = self.client.call_async(request)\r\n\r\n        # Register callback for when response arrives\r\n        future.add_done_callback(self.handle_response)\r\n\r\n    def handle_response(self, future):\r\n        """\r\n        Called when service response is received.\r\n\r\n        Args:\r\n            future: Future object containing response\r\n        """\r\n        try:\r\n            response = future.result()\r\n            self.get_logger().info(\'IK solution received\')\r\n            # Process response.plan data here\r\n        except Exception as e:\r\n            self.get_logger().error(f\'Service call failed: {e}\')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    client = IKClient()\r\n\r\n    # Request IK for position (0.4, 0.3)\r\n    client.send_request(0.4, 0.3)\r\n\r\n    # Spin to process callbacks\r\n    rclpy.spin(client)\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,t.jsx)(r.h2,{id:"action-servers-long-running-tasks",children:"Action Servers: Long-Running Tasks"}),"\n",(0,t.jsx)(r.p,{children:"Actions extend services for operations that take significant time (seconds to minutes) and require progress feedback. Examples include:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Walking to a destination (report distance remaining)"}),"\n",(0,t.jsx)(r.li,{children:"Grasping an object (report contact forces during approach)"}),"\n",(0,t.jsx)(r.li,{children:"Standup sequence (report completion of each phase)"}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"action-structure",children:"Action Structure"}),"\n",(0,t.jsx)(r.p,{children:"Actions have three components:"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Goal"}),": Request message (e.g., target position for walking)"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Result"}),": Final outcome (e.g., success/failure, final pose)"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Feedback"}),": Periodic progress updates (e.g., current distance to goal)"]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["Actions also support ",(0,t.jsx)(r.strong,{children:"cancellation"}),"\u2014critical for safety when a humanoid must abort a motion."]}),"\n",(0,t.jsx)(r.h2,{id:"action-server-example-walk-to-position",children:"Action Server Example: Walk to Position"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"\r\nAction server for humanoid walking.\r\nExecutes walk commands with progress feedback.\r\n\"\"\"\r\n\r\nimport rclpy\r\nfrom rclpy.action import ActionServer\r\nfrom rclpy.node import Node\r\nfrom action_msgs.msg import GoalStatus\r\n# In production, define custom action: WalkToPosition.action\r\n# For demo, using example action type\r\nfrom example_interfaces.action import Fibonacci\r\nimport time\r\n\r\nclass WalkActionServer(Node):\r\n    \"\"\"\r\n    Executes walking motions as long-running actions.\r\n    \"\"\"\r\n\r\n    def __init__(self):\r\n        super().__init__('walk_action_server')\r\n\r\n        # Create action server\r\n        self._action_server = ActionServer(\r\n            self,\r\n            Fibonacci,  # Replace with custom WalkToPosition action\r\n            'walk_to_position',\r\n            self.execute_callback\r\n        )\r\n\r\n        # Walking parameters\r\n        self.walking_speed = 0.5  # m/s\r\n\r\n        self.get_logger().info('Walk action server started')\r\n\r\n    def execute_callback(self, goal_handle):\r\n        \"\"\"\r\n        Execute walking action.\r\n\r\n        Args:\r\n            goal_handle: Handle for managing action execution\r\n\r\n        Returns:\r\n            Result message\r\n        \"\"\"\r\n        self.get_logger().info('Executing walk action')\r\n\r\n        # Extract goal (in real action, this would be target pose)\r\n        target_distance = 2.0  # meters\r\n        steps_required = int(target_distance / self.walking_speed)\r\n\r\n        # Create feedback message\r\n        feedback_msg = Fibonacci.Feedback()\r\n\r\n        # Simulate walking with periodic feedback\r\n        for step in range(steps_required):\r\n            # Check if cancellation requested\r\n            if goal_handle.is_cancel_requested:\r\n                goal_handle.canceled()\r\n                self.get_logger().info('Walk action canceled')\r\n                return Fibonacci.Result()\r\n\r\n            # Compute progress\r\n            distance_covered = step * self.walking_speed\r\n            distance_remaining = target_distance - distance_covered\r\n\r\n            # Publish feedback (in real implementation, include current pose)\r\n            feedback_msg.sequence = [int(distance_covered * 100), int(distance_remaining * 100)]\r\n            goal_handle.publish_feedback(feedback_msg)\r\n\r\n            self.get_logger().info(\r\n                f'Walking: {distance_covered:.2f}m covered, '\r\n                f'{distance_remaining:.2f}m remaining'\r\n            )\r\n\r\n            # Simulate one second of walking\r\n            time.sleep(1.0)\r\n\r\n        # Mark action as succeeded\r\n        goal_handle.succeed()\r\n\r\n        # Return result\r\n        result = Fibonacci.Result()\r\n        result.sequence = [int(target_distance * 100)]\r\n        self.get_logger().info(f'Walk completed: {target_distance}m')\r\n\r\n        return result\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = WalkActionServer()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info('Shutting down walk action server')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsx)(r.h2,{id:"parameters-and-dynamic-reconfigure",children:"Parameters and Dynamic Reconfigure"}),"\n",(0,t.jsx)(r.p,{children:"Parameters allow runtime configuration without restarting nodes\u2014essential for tuning controller gains during testing."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"\r\nDemonstrates ROS 2 parameter usage for controller tuning.\r\n\"\"\"\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom rcl_interfaces.msg import SetParametersResult\r\n\r\nclass BalanceController(Node):\r\n    def __init__(self):\r\n        super().__init__('balance_controller')\r\n\r\n        # Declare parameters with default values\r\n        self.declare_parameter('kp_pitch', 50.0)   # Proportional gain for pitch\r\n        self.declare_parameter('kd_pitch', 10.0)   # Derivative gain\r\n        self.declare_parameter('kp_roll', 50.0)\r\n        self.declare_parameter('kd_roll', 10.0)\r\n        self.declare_parameter('max_torque', 100.0)  # Nm\r\n\r\n        # Register callback for parameter changes\r\n        self.add_on_set_parameters_callback(self.parameter_callback)\r\n\r\n        # Read initial parameter values\r\n        self.update_gains()\r\n\r\n        self.get_logger().info(\r\n            f'Balance controller initialized: '\r\n            f'kp_pitch={self.kp_pitch}, kd_pitch={self.kd_pitch}'\r\n        )\r\n\r\n    def update_gains(self):\r\n        \"\"\"Read current parameter values.\"\"\"\r\n        self.kp_pitch = self.get_parameter('kp_pitch').value\r\n        self.kd_pitch = self.get_parameter('kd_pitch').value\r\n        self.kp_roll = self.get_parameter('kp_roll').value\r\n        self.kd_roll = self.get_parameter('kd_roll').value\r\n        self.max_torque = self.get_parameter('max_torque').value\r\n\r\n    def parameter_callback(self, params):\r\n        \"\"\"\r\n        Called when parameters are changed via CLI or service.\r\n\r\n        Args:\r\n            params: List of parameters being modified\r\n\r\n        Returns:\r\n            SetParametersResult: Success/failure indicator\r\n        \"\"\"\r\n        for param in params:\r\n            self.get_logger().info(f'Parameter changed: {param.name} = {param.value}')\r\n\r\n        # Update internal gains\r\n        self.update_gains()\r\n\r\n        # Validate parameters (example: ensure gains are positive)\r\n        if self.kp_pitch < 0 or self.kd_pitch < 0:\r\n            self.get_logger().error('Gains must be positive')\r\n            return SetParametersResult(successful=False)\r\n\r\n        return SetParametersResult(successful=True)\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = BalanceController()\r\n    rclpy.spin(node)\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsx)(r.h3,{id:"using-parameters-from-cli",children:"Using Parameters from CLI"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-bash",children:"# Get current parameter values\r\nros2 param get /balance_controller kp_pitch\r\n\r\n# Set new value (triggers callback)\r\nros2 param set /balance_controller kp_pitch 75.0\r\n\r\n# List all parameters for a node\r\nros2 param list /balance_controller\r\n\r\n# Save parameters to YAML file\r\nros2 param dump /balance_controller > controller_params.yaml\r\n\r\n# Load parameters from file on startup\r\nros2 run humanoid_control balance_controller --ros-args --params-file controller_params.yaml\n"})}),"\n",(0,t.jsx)(r.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(r.p,{children:["You now understand services for request-response operations, actions for long-running tasks with feedback, and parameters for runtime configuration. The next chapter, ",(0,t.jsx)(r.strong,{children:"Week 5: URDF"}),", introduces robot modeling\u2014defining the kinematic structure of a humanoid robot for simulation and control."]}),"\n",(0,t.jsx)(r.h3,{id:"practice-exercise",children:"Practice Exercise"}),"\n",(0,t.jsx)(r.p,{children:"Create an action client that:"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsx)(r.li,{children:"Sends a walk goal to the action server"}),"\n",(0,t.jsx)(r.li,{children:"Displays progress feedback in the terminal"}),"\n",(0,t.jsx)(r.li,{children:"Cancels the action if user presses 'q'"}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["Hint: Use ",(0,t.jsx)(r.code,{children:"rclpy.action.ActionClient"})," and register callbacks for feedback, result, and goal_response."]})]})}function p(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},5818:(e,r,n)=>{n.d(r,{A:()=>s});const s=n.p+"assets/images/ai-6-abcf4be7763f58bf15e987b6b05b86a7.png"},8453:(e,r,n)=>{n.d(r,{R:()=>i,x:()=>o});var s=n(6540);const t={},a=s.createContext(t);function i(e){const r=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(a.Provider,{value:r},e.children)}}}]);