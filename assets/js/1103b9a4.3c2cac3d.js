"use strict";(globalThis.webpackChunkphysical_ai_robotics=globalThis.webpackChunkphysical_ai_robotics||[]).push([[3738],{5368:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"module-04-vla/week-11-llm-planning","title":"Week 11: LLM-Based Task Planning","description":"Using GPT-4 for Robot Task Planning","source":"@site/docs/module-04-vla/week-11-llm-planning.md","sourceDirName":"module-04-vla","slug":"/module-04-vla/week-11-llm-planning","permalink":"/physical-ai-robotics/docs/module-04-vla/week-11-llm-planning","draft":false,"unlisted":false,"editUrl":"https://github.com/Rao-Faizan/physical-ai-robotics/tree/main/frontend/docs/module-04-vla/week-11-llm-planning.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Week 11: Voice-to-Action Pipeline","permalink":"/physical-ai-robotics/docs/module-04-vla/week-11-voice-to-action"},"next":{"title":"Week 12: Multimodal Vision-Language Fusion","permalink":"/physical-ai-robotics/docs/module-04-vla/week-12-multimodal"}}');var o=t(4848),i=t(8453);const a={},s="Week 11: LLM-Based Task Planning",l={},c=[{value:"Using GPT-4 for Robot Task Planning",id:"using-gpt-4-for-robot-task-planning",level:2},{value:"Why LLMs for Planning?",id:"why-llms-for-planning",level:3},{value:"Basic Task Decomposition",id:"basic-task-decomposition",level:3},{value:"The ReAct Pattern: Reasoning + Acting",id:"the-react-pattern-reasoning--acting",level:2},{value:"ReAct Architecture",id:"react-architecture",level:3},{value:"Implementation",id:"implementation",level:3},{value:"Chain-of-Thought for Robots",id:"chain-of-thought-for-robots",level:2},{value:"CoT for Manipulation Planning",id:"cot-for-manipulation-planning",level:3},{value:"Prompt Engineering Best Practices",id:"prompt-engineering-best-practices",level:2},{value:"Practice Exercise",id:"practice-exercise",level:3},{value:"Next Steps",id:"next-steps",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"week-11-llm-based-task-planning",children:"Week 11: LLM-Based Task Planning"})}),"\n",(0,o.jsx)(n.h2,{id:"using-gpt-4-for-robot-task-planning",children:"Using GPT-4 for Robot Task Planning"}),"\n",(0,o.jsx)(n.p,{children:'Large Language Models excel at decomposing high-level goals into executable sub-tasks by leveraging common-sense reasoning learned from internet-scale text data. For robotics, this means translating vague instructions like "prepare breakfast" into concrete action sequences: navigate to kitchen, open fridge, retrieve eggs, close fridge, navigate to stove, etc.'}),"\n",(0,o.jsx)(n.h3,{id:"why-llms-for-planning",children:"Why LLMs for Planning?"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Generalization"}),": Traditional planners (PDDL, hierarchical task networks) require manually authored domain models. LLMs learn task structure implicitly from diverse text\u2014recipes, instruction manuals, how-to guides\u2014enabling zero-shot planning for novel tasks."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Contextual Reasoning"}),': LLMs infer implicit constraints. Given "make coffee," they know to check if water is available before attempting to brew, without explicit preconditions in code.']}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Natural Language Interface"}),': Users provide goals in free-form language instead of formal specifications. "Help me set the table for dinner" is more intuitive than ',(0,o.jsx)(n.code,{children:"set_table(num_plates=4, silverware=True)"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Failure Recovery"}),": When plans fail, LLMs replan based on error descriptions, exhibiting adaptive behavior rare in classical planners."]}),"\n",(0,o.jsx)(n.h3,{id:"basic-task-decomposition",children:"Basic Task Decomposition"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import openai\r\nimport os\r\nfrom typing import List, Dict\r\n\r\nopenai.api_key = os.getenv("OPENAI_API_KEY")\r\n\r\ndef plan_task(goal: str, context: str = "") -> List[str]:\r\n    """\r\n    Generate step-by-step plan for achieving robot goal.\r\n\r\n    Args:\r\n        goal: High-level objective (e.g., "clean the living room")\r\n        context: Environmental state (e.g., "vacuum is in closet, trash bin is full")\r\n\r\n    Returns:\r\n        List of action steps in execution order\r\n    """\r\n    # System prompt defines robot\'s action space and constraints\r\n    system_prompt = """You are a task planner for a humanoid robot.\r\n    Break down user goals into sequential steps using available actions.\r\n\r\n    Available actions:\r\n    - navigate(location): Move to specified location\r\n    - pick(object): Grasp object in front of robot\r\n    - place(object, location): Put held object at location\r\n    - open(object): Open door/drawer/container\r\n    - close(object): Close door/drawer/container\r\n    - activate(device): Turn on appliance/switch\r\n    - deactivate(device): Turn off appliance/switch\r\n\r\n    Constraints:\r\n    - Robot can hold one object at a time (must place before picking new object)\r\n    - Navigation requires clear path (cannot walk through closed doors)\r\n    - Object must be within reach (navigate first if not visible)\r\n\r\n    Return numbered list of steps. Be concise.\r\n    """\r\n\r\n    # Include environmental context to inform plan\r\n    user_prompt = f"""Goal: {goal}\r\n\r\n    Current environment: {context if context else "Unknown state"}\r\n\r\n    Generate action plan:\r\n    """\r\n\r\n    response = openai.ChatCompletion.create(\r\n        model="gpt-4",\r\n        messages=[\r\n            {"role": "system", "content": system_prompt},\r\n            {"role": "user", "content": user_prompt}\r\n        ],\r\n        temperature=0.3,  # Low temperature for consistent planning\r\n        max_tokens=300\r\n    )\r\n\r\n    # Parse numbered list into steps\r\n    plan_text = response.choices[0].message.content\r\n    steps = [\r\n        line.strip()\r\n        for line in plan_text.split(\'\\n\')\r\n        if line.strip() and line.strip()[0].isdigit()\r\n    ]\r\n    return steps\r\n\r\n# Example: Home assistance task\r\ngoal = "Prepare a cup of coffee"\r\ncontext = "You are in the living room. Coffee maker is in the kitchen."\r\n\r\nplan = plan_task(goal, context)\r\nfor i, step in enumerate(plan, 1):\r\n    print(f"{i}. {step}")\r\n\r\n# Output:\r\n# 1. navigate(kitchen)\r\n# 2. open(cabinet) to access coffee grounds\r\n# 3. pick(coffee_grounds)\r\n# 4. place(coffee_grounds, coffee_maker)\r\n# 5. close(cabinet)\r\n# 6. activate(coffee_maker)\r\n# 7. pick(mug)\r\n# 8. place(mug, coffee_maker)\n'})}),"\n",(0,o.jsx)(n.h2,{id:"the-react-pattern-reasoning--acting",children:"The ReAct Pattern: Reasoning + Acting"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.strong,{children:"ReAct"})," (Reasoning and Acting) pattern interleaves thought generation with action execution, allowing LLMs to adaptively adjust plans based on real-time feedback. Unlike open-loop planning (generate entire plan upfront), ReAct performs closed-loop reasoning at each step."]}),"\n",(0,o.jsx)(n.h3,{id:"react-architecture",children:"ReAct Architecture"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Observation \u2192 Thought \u2192 Action \u2192 Observation \u2192 Thought \u2192 Action \u2192 ...\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Observation"}),": Current world state from sensors (object positions, door status, battery level)\r\n",(0,o.jsx)(n.strong,{children:"Thought"}),": LLM-generated reasoning about what to do next\r\n",(0,o.jsx)(n.strong,{children:"Action"}),": Executable robot command\r\n",(0,o.jsx)(n.strong,{children:"Loop"}),": Repeat until goal achieved or failure detected"]}),"\n",(0,o.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import json\r\nfrom typing import Tuple, Optional\r\n\r\nclass ReActAgent:\r\n    """\r\n    ReAct agent for adaptive robot task execution.\r\n    Combines LLM reasoning with environmental feedback.\r\n    """\r\n\r\n    def __init__(self, max_steps: int = 10):\r\n        self.max_steps = max_steps\r\n        self.history = []  # Track (thought, action, observation) tuples\r\n\r\n    def run(self, goal: str, get_observation_fn) -> bool:\r\n        """\r\n        Execute goal using ReAct loop.\r\n\r\n        Args:\r\n            goal: Task objective\r\n            get_observation_fn: Callable returning current world state\r\n\r\n        Returns:\r\n            bool: True if goal achieved, False if failed\r\n        """\r\n        observation = get_observation_fn()\r\n        self.history = []\r\n\r\n        for step in range(self.max_steps):\r\n            # Generate thought and action from LLM\r\n            thought, action = self._reason(goal, observation)\r\n            self.history.append((thought, action, observation))\r\n\r\n            print(f"\\n--- Step {step + 1} ---")\r\n            print(f"Observation: {observation}")\r\n            print(f"Thought: {thought}")\r\n            print(f"Action: {action}")\r\n\r\n            # Check for task completion or failure\r\n            if action == "DONE":\r\n                print("Goal achieved!")\r\n                return True\r\n            if action == "FAIL":\r\n                print(f"Task failed: {thought}")\r\n                return False\r\n\r\n            # Execute action and get new observation\r\n            observation = self._execute_action(action, get_observation_fn)\r\n\r\n        print("Max steps reached without completion.")\r\n        return False\r\n\r\n    def _reason(self, goal: str, observation: str) -> Tuple[str, str]:\r\n        """\r\n        Generate reasoning and next action.\r\n\r\n        Returns:\r\n            (thought, action): Reasoning string and action command\r\n        """\r\n        # Build prompt with full history for context\r\n        history_text = "\\n".join([\r\n            f"Thought: {t}\\nAction: {a}\\nObservation: {o}"\r\n            for t, a, o in self.history\r\n        ])\r\n\r\n        prompt = f"""You are controlling a humanoid robot. Use step-by-step reasoning.\r\n\r\nGoal: {goal}\r\n\r\nPrevious steps:\r\n{history_text if history_text else "None (this is the first step)"}\r\n\r\nCurrent observation: {observation}\r\n\r\nThink about what to do next. Format your response as:\r\nThought: [your reasoning]\r\nAction: [command]\r\n\r\nUse \'DONE\' action when goal is achieved, \'FAIL\' if impossible.\r\nAvailable actions: navigate(loc), pick(obj), place(obj, loc), open(obj), close(obj), check(obj).\r\n"""\r\n\r\n        response = openai.ChatCompletion.create(\r\n            model="gpt-4",\r\n            messages=[{"role": "user", "content": prompt}],\r\n            temperature=0.2,\r\n            max_tokens=150\r\n        )\r\n\r\n        # Parse thought and action from response\r\n        text = response.choices[0].message.content\r\n        lines = text.strip().split(\'\\n\')\r\n\r\n        thought = ""\r\n        action = ""\r\n        for line in lines:\r\n            if line.startswith("Thought:"):\r\n                thought = line.replace("Thought:", "").strip()\r\n            elif line.startswith("Action:"):\r\n                action = line.replace("Action:", "").strip()\r\n\r\n        return thought, action\r\n\r\n    def _execute_action(self, action: str, get_observation_fn) -> str:\r\n        """\r\n        Execute action command (mock implementation).\r\n        In real system, this calls ROS 2 action servers.\r\n        """\r\n        # Simulate action execution (replace with actual robot interface)\r\n        print(f"Executing: {action}")\r\n\r\n        # Return updated observation after action\r\n        # In production: query sensors/perception system\r\n        return get_observation_fn()\r\n\r\n# Example usage with mock environment\r\ndef mock_get_observation():\r\n    """\r\n    Mock sensor reading (replace with actual perception system).\r\n    In real system: query object detector, SLAM map, joint states.\r\n    """\r\n    # Simulate changing observations based on agent\'s actions\r\n    observations = [\r\n        "You are in living room. Coffee maker visible in kitchen.",\r\n        "You are in kitchen. Coffee maker is on counter. Mug is in cabinet.",\r\n        "Cabinet is open. Mug is visible.",\r\n        "You are holding mug. Coffee maker has finished brewing.",\r\n        "Mug is placed under coffee maker spout."\r\n    ]\r\n    # Cycle through observations (simplified; real system queries sensors)\r\n    return observations[len(agent.history) % len(observations)]\r\n\r\n# Run ReAct agent\r\nagent = ReActAgent(max_steps=8)\r\nsuccess = agent.run(\r\n    goal="Serve a cup of coffee",\r\n    get_observation_fn=mock_get_observation\r\n)\n'})}),"\n",(0,o.jsx)(n.h2,{id:"chain-of-thought-for-robots",children:"Chain-of-Thought for Robots"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Chain-of-Thought (CoT)"})," prompting elicits intermediate reasoning steps, improving LLM performance on complex tasks. For robotics, CoT helps decompose spatiotemporal reasoning:"]}),"\n",(0,o.jsx)(n.h3,{id:"cot-for-manipulation-planning",children:"CoT for Manipulation Planning"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'def plan_grasp_with_cot(object_name: str, scene_description: str) -> Dict:\r\n    """\r\n    Generate grasp plan using chain-of-thought reasoning.\r\n\r\n    Args:\r\n        object_name: Target object to grasp\r\n        scene_description: Visual scene layout\r\n\r\n    Returns:\r\n        dict: Grasp strategy with approach vector, contact points\r\n    """\r\n    prompt = f"""You are planning a grasp for a humanoid robot arm.\r\n\r\nObject: {object_name}\r\nScene: {scene_description}\r\n\r\nThink step-by-step:\r\n1. What is the object\'s shape and likely material?\r\n2. What grasp type is appropriate (pinch, power, lateral)?\r\n3. From which direction should the robot approach?\r\n4. What are potential failure modes (slipping, collision)?\r\n\r\nThen output JSON grasp plan:\r\n{{\r\n    "grasp_type": "pinch | power | lateral",\r\n    "approach_direction": "top | side | front",\r\n    "contact_points": ["finger1_location", "finger2_location"],\r\n    "expected_force": "low | medium | high"\r\n}}\r\n"""\r\n\r\n    response = openai.ChatCompletion.create(\r\n        model="gpt-4",\r\n        messages=[{"role": "user", "content": prompt}],\r\n        temperature=0.1\r\n    )\r\n\r\n    # Extract JSON from response\r\n    text = response.choices[0].message.content\r\n    # Find JSON block in response\r\n    start = text.find(\'{\')\r\n    end = text.rfind(\'}\') + 1\r\n    if start != -1 and end > start:\r\n        grasp_plan = json.loads(text[start:end])\r\n        return grasp_plan\r\n\r\n    return {"error": "Failed to generate grasp plan"}\r\n\r\n# Example: Grasp planning\r\nresult = plan_grasp_with_cot(\r\n    object_name="wine glass",\r\n    scene_description="Wine glass on table, stem visible, surrounded by plates"\r\n)\r\nprint(json.dumps(result, indent=2))\n'})}),"\n",(0,o.jsx)(n.h2,{id:"prompt-engineering-best-practices",children:"Prompt Engineering Best Practices"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"System Role"}),": Define robot's capabilities and constraints clearly\r\n",(0,o.jsx)(n.strong,{children:"Few-Shot Examples"}),": Provide 2-3 example plans for similar tasks\r\n",(0,o.jsx)(n.strong,{children:"Output Format"}),": Specify structured output (JSON, numbered lists) for reliable parsing\r\n",(0,o.jsx)(n.strong,{children:"Context Window"}),": Include recent observations (last 5 steps) but prune old history to stay within token limits\r\n",(0,o.jsx)(n.strong,{children:"Error Handling"}),': Prompt LLM to output "UNCERTAIN" when insufficient information; query human for clarification']}),"\n",(0,o.jsx)(n.h3,{id:"practice-exercise",children:"Practice Exercise"}),"\n",(0,o.jsx)(n.p,{children:"Implement a ReAct agent that:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:'Takes high-level goal: "Set the dinner table for 4 people"'}),"\n",(0,o.jsx)(n.li,{children:"Queries mock environment for object locations"}),"\n",(0,o.jsx)(n.li,{children:"Generates plans adaptively (if plates unavailable, try alternative location)"}),"\n",(0,o.jsx)(n.li,{children:"Handles failures gracefully (if object too heavy, request human assistance)"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Extend with ",(0,o.jsx)(n.strong,{children:"reflection"}),": after failed attempt, prompt LLM to analyze failure and propose alternative strategy."]}),"\n",(0,o.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,o.jsxs)(n.p,{children:["You've implemented LLM-based planning for sequential task execution. In ",(0,o.jsx)(n.strong,{children:"Week 12: Multimodal Integration"}),', you\'ll connect language understanding to visual perception using CLIP, enabling robots to ground commands like "the red object" to specific scene entities.']})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var r=t(6540);const o={},i=r.createContext(o);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);