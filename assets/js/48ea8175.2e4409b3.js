"use strict";(globalThis.webpackChunkphysical_ai_robotics=globalThis.webpackChunkphysical_ai_robotics||[]).push([[2700],{5566:(r,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>t,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module-01-ros2/week-5-urdf","title":"Week 5: URDF for Humanoid Robots","description":"Introduction to URDF","source":"@site/docs/module-01-ros2/week-5-urdf.md","sourceDirName":"module-01-ros2","slug":"/module-01-ros2/week-5-urdf","permalink":"/physical-ai-robotics/docs/module-01-ros2/week-5-urdf","draft":false,"unlisted":false,"editUrl":"https://github.com/Rao-Faizan/physical-ai-robotics/tree/main/frontend/docs/module-01-ros2/week-5-urdf.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Week 4: Services and Actions","permalink":"/physical-ai-robotics/docs/module-01-ros2/week-4-services-actions"},"next":{"title":"Week 5: ros2_control Framework","permalink":"/physical-ai-robotics/docs/module-01-ros2/week-5-control"}}');var o=n(4848),s=n(8453);const t={},a="Week 5: URDF for Humanoid Robots",l={},c=[{value:"Introduction to URDF",id:"introduction-to-urdf",level:2},{value:"URDF Philosophy",id:"urdf-philosophy",level:3},{value:"Joint Types",id:"joint-types",level:2},{value:"Revolute Joints",id:"revolute-joints",level:3},{value:"Prismatic Joints",id:"prismatic-joints",level:3},{value:"Continuous Joints",id:"continuous-joints",level:3},{value:"Fixed Joints",id:"fixed-joints",level:3},{value:"Link Structure: Visual and Collision Geometry",id:"link-structure-visual-and-collision-geometry",level:2},{value:"Geometry Options",id:"geometry-options",level:3},{value:"Xacro: Modular URDF",id:"xacro-modular-urdf",level:2},{value:"Xacro Example: Parameterized Arm",id:"xacro-example-parameterized-arm",level:3},{value:"Processing Xacro Files",id:"processing-xacro-files",level:3},{value:"Complete Humanoid URDF Example",id:"complete-humanoid-urdf-example",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Next Steps",id:"next-steps",level:2},{value:"Practice Exercise",id:"practice-exercise",level:3}];function d(r){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...r.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"week-5-urdf-for-humanoid-robots",children:"Week 5: URDF for Humanoid Robots"})}),"\n",(0,o.jsx)(e.h2,{id:"introduction-to-urdf",children:"Introduction to URDF"}),"\n",(0,o.jsx)(e.p,{children:"The Unified Robot Description Format (URDF) is an XML-based specification for describing robot kinematics, dynamics, and visual appearance. URDF files define the robot's structure as a tree of links (rigid bodies) connected by joints (movable or fixed connections)."}),"\n",(0,o.jsx)(e.p,{children:"For humanoid robots, URDF enables:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Simulation"}),": Visualize robot motion in Gazebo or RViz before hardware testing"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Kinematics"}),": Compute forward/inverse kinematics for pose planning"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Collision detection"}),": Prevent self-collisions during complex motions"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Control"}),": Generate controller configurations from joint definitions"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"urdf-philosophy",children:"URDF Philosophy"}),"\n",(0,o.jsxs)(e.p,{children:["URDF represents robots as kinematic trees with a single root link (typically ",(0,o.jsx)(e.code,{children:"base_link"}),"). Each joint connects a parent link to a child link, defining the relative motion between them. This tree structure matches the physical reality of most robots: a humanoid has a torso (root) with limbs branching outward."]}),"\n",(0,o.jsx)(e.h2,{id:"joint-types",children:"Joint Types"}),"\n",(0,o.jsx)(e.p,{children:"URDF supports six joint types, each defining different motion constraints:"}),"\n",(0,o.jsx)(e.h3,{id:"revolute-joints",children:"Revolute Joints"}),"\n",(0,o.jsx)(e.p,{children:"Rotate around a single axis with angle limits (most common for robot joints)."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Shoulder pitch joint: rotates around Y-axis --\x3e\r\n<joint name="left_shoulder_pitch" type="revolute">\r\n  <parent link="torso"/>\r\n  <child link="left_upper_arm"/>\r\n\r\n  \x3c!-- Joint origin relative to parent link --\x3e\r\n  <origin xyz="0.0 0.15 0.4" rpy="0 0 0"/>\r\n\r\n  \x3c!-- Axis of rotation in joint frame --\x3e\r\n  <axis xyz="0 1 0"/>\r\n\r\n  \x3c!-- Joint limits (radians) --\x3e\r\n  <limit lower="-1.57" upper="1.57" effort="100.0" velocity="2.0"/>\r\n\r\n  \x3c!-- Joint dynamics (optional) --\x3e\r\n  <dynamics damping="0.7" friction="0.5"/>\r\n</joint>\n'})}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Parameters"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"lower/upper"}),": Angle limits in radians (\xb190\xb0 in this example)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"effort"}),": Maximum torque (Nm) the actuator can apply"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"velocity"}),": Maximum angular velocity (rad/s)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"damping"}),": Simulates energy dissipation in bearings"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"friction"}),": Models static/kinetic friction"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"prismatic-joints",children:"Prismatic Joints"}),"\n",(0,o.jsx)(e.p,{children:"Translate along a single axis (used for telescoping limbs or linear actuators)."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Telescoping torso joint --\x3e\r\n<joint name="torso_lift" type="prismatic">\r\n  <parent link="base_link"/>\r\n  <child link="torso"/>\r\n\r\n  <origin xyz="0 0 0.5" rpy="0 0 0"/>\r\n\r\n  \x3c!-- Axis of translation --\x3e\r\n  <axis xyz="0 0 1"/>\r\n\r\n  \x3c!-- Linear limits (meters) --\x3e\r\n  <limit lower="0.0" upper="0.3" effort="500.0" velocity="0.1"/>\r\n</joint>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"continuous-joints",children:"Continuous Joints"}),"\n",(0,o.jsx)(e.p,{children:"Revolute joints without angle limits (for wheels or unrestricted rotation)."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Waist rotation (360\xb0 rotation) --\x3e\r\n<joint name="waist_yaw" type="continuous">\r\n  <parent link="pelvis"/>\r\n  <child link="torso"/>\r\n  <origin xyz="0 0 0.1" rpy="0 0 0"/>\r\n  <axis xyz="0 0 1"/>\r\n  <limit effort="80.0" velocity="1.5"/>\r\n</joint>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"fixed-joints",children:"Fixed Joints"}),"\n",(0,o.jsx)(e.p,{children:"Rigidly attach links (no motion). Used for sensors, end-effectors, or structural components."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Camera mounted on head --\x3e\r\n<joint name="head_camera_joint" type="fixed">\r\n  <parent link="head"/>\r\n  <child link="camera_link"/>\r\n  <origin xyz="0.05 0 0.05" rpy="0 0 0"/>\r\n</joint>\n'})}),"\n",(0,o.jsx)(e.h2,{id:"link-structure-visual-and-collision-geometry",children:"Link Structure: Visual and Collision Geometry"}),"\n",(0,o.jsx)(e.p,{children:"Each link defines both visual appearance (for rendering) and collision geometry (for physics simulation)."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<link name="left_upper_arm">\r\n  \x3c!-- Visual appearance (what you see in RViz/Gazebo) --\x3e\r\n  <visual>\r\n    <origin xyz="0 0 -0.15" rpy="0 0 0"/>\r\n    <geometry>\r\n      \x3c!-- Cylinder: radius=0.05m, length=0.3m --\x3e\r\n      <cylinder radius="0.05" length="0.3"/>\r\n    </geometry>\r\n    <material name="blue">\r\n      <color rgba="0.0 0.0 0.8 1.0"/>\r\n    </material>\r\n  </visual>\r\n\r\n  \x3c!-- Collision geometry (for physics/contact detection) --\x3e\r\n  \x3c!-- Often simplified for performance --\x3e\r\n  <collision>\r\n    <origin xyz="0 0 -0.15" rpy="0 0 0"/>\r\n    <geometry>\r\n      \x3c!-- Same as visual for simple shapes --\x3e\r\n      <cylinder radius="0.05" length="0.3"/>\r\n    </geometry>\r\n  </collision>\r\n\r\n  \x3c!-- Inertial properties (for dynamics simulation) --\x3e\r\n  <inertial>\r\n    <origin xyz="0 0 -0.15" rpy="0 0 0"/>\r\n    <mass value="2.5"/>  \x3c!-- kg --\x3e\r\n\r\n    \x3c!-- Inertia tensor for cylinder about center of mass --\x3e\r\n    \x3c!-- Computed using: I = m*r\xb2/2 (z-axis), I = m*(3r\xb2+h\xb2)/12 (x,y-axes) --\x3e\r\n    <inertia\r\n      ixx="0.0208" ixy="0.0" ixz="0.0"\r\n      iyy="0.0208" iyz="0.0"\r\n      izz="0.003125"/>\r\n  </inertial>\r\n</link>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"geometry-options",children:"Geometry Options"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Box (width, depth, height in meters) --\x3e\r\n<geometry>\r\n  <box size="0.1 0.2 0.05"/>\r\n</geometry>\r\n\r\n\x3c!-- Sphere (radius in meters) --\x3e\r\n<geometry>\r\n  <sphere radius="0.08"/>\r\n</geometry>\r\n\r\n\x3c!-- Mesh (load from STL/DAE file) --\x3e\r\n<geometry>\r\n  <mesh filename="package://humanoid_description/meshes/hand.stl" scale="1.0 1.0 1.0"/>\r\n</geometry>\n'})}),"\n",(0,o.jsx)(e.h2,{id:"xacro-modular-urdf",children:"Xacro: Modular URDF"}),"\n",(0,o.jsx)(e.p,{children:"Writing raw URDF for complex robots leads to repetitive code. Xacro (XML Macros) extends URDF with:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Variables"}),": Define constants (link lengths, masses)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Macros"}),": Reusable templates for repeated structures (left/right limbs)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Math"}),": Compute values (inertia tensors, compound transforms)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"File inclusion"}),": Split robot into modular files"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"xacro-example-parameterized-arm",children:"Xacro Example: Parameterized Arm"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\r\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="humanoid_arm">\r\n\r\n  \x3c!-- Define constants --\x3e\r\n  <xacro:property name="upper_arm_length" value="0.3"/>\r\n  <xacro:property name="forearm_length" value="0.25"/>\r\n  <xacro:property name="arm_radius" value="0.05"/>\r\n  <xacro:property name="arm_mass" value="2.5"/>\r\n\r\n  \x3c!-- Macro for arm links (reusable for left/right) --\x3e\r\n  <xacro:macro name="arm_links" params="side reflect">\r\n\r\n    \x3c!-- Upper arm link --\x3e\r\n    <link name="${side}_upper_arm">\r\n      <visual>\r\n        <origin xyz="0 0 ${-upper_arm_length/2}" rpy="0 0 0"/>\r\n        <geometry>\r\n          <cylinder radius="${arm_radius}" length="${upper_arm_length}"/>\r\n        </geometry>\r\n        <material name="blue">\r\n          <color rgba="0.2 0.2 0.8 1.0"/>\r\n        </material>\r\n      </visual>\r\n\r\n      <collision>\r\n        <origin xyz="0 0 ${-upper_arm_length/2}" rpy="0 0 0"/>\r\n        <geometry>\r\n          <cylinder radius="${arm_radius}" length="${upper_arm_length}"/>\r\n        </geometry>\r\n      </collision>\r\n\r\n      <xacro:cylinder_inertia\r\n        mass="${arm_mass}"\r\n        radius="${arm_radius}"\r\n        length="${upper_arm_length}"/>\r\n    </link>\r\n\r\n    \x3c!-- Shoulder joint --\x3e\r\n    <joint name="${side}_shoulder_pitch" type="revolute">\r\n      <parent link="torso"/>\r\n      <child link="${side}_upper_arm"/>\r\n\r\n      \x3c!-- Reflect parameter: 1 for left, -1 for right --\x3e\r\n      <origin xyz="0.0 ${reflect * 0.15} 0.4" rpy="0 0 0"/>\r\n\r\n      <axis xyz="0 1 0"/>\r\n      <limit lower="-1.57" upper="1.57" effort="100.0" velocity="2.0"/>\r\n      <dynamics damping="0.7"/>\r\n    </joint>\r\n\r\n    \x3c!-- Forearm link --\x3e\r\n    <link name="${side}_forearm">\r\n      <visual>\r\n        <origin xyz="0 0 ${-forearm_length/2}" rpy="0 0 0"/>\r\n        <geometry>\r\n          <cylinder radius="${arm_radius * 0.8}" length="${forearm_length}"/>\r\n        </geometry>\r\n        <material name="blue"/>\r\n      </visual>\r\n\r\n      <collision>\r\n        <origin xyz="0 0 ${-forearm_length/2}" rpy="0 0 0"/>\r\n        <geometry>\r\n          <cylinder radius="${arm_radius * 0.8}" length="${forearm_length}"/>\r\n        </geometry>\r\n      </collision>\r\n\r\n      <xacro:cylinder_inertia\r\n        mass="${arm_mass * 0.8}"\r\n        radius="${arm_radius * 0.8}"\r\n        length="${forearm_length}"/>\r\n    </link>\r\n\r\n    \x3c!-- Elbow joint --\x3e\r\n    <joint name="${side}_elbow" type="revolute">\r\n      <parent link="${side}_upper_arm"/>\r\n      <child link="${side}_forearm"/>\r\n\r\n      <origin xyz="0 0 ${-upper_arm_length}" rpy="0 0 0"/>\r\n\r\n      <axis xyz="0 1 0"/>\r\n      \x3c!-- Elbow only bends one direction --\x3e\r\n      <limit lower="0.0" upper="2.356" effort="80.0" velocity="2.0"/>\r\n      <dynamics damping="0.5"/>\r\n    </joint>\r\n\r\n  </xacro:macro>\r\n\r\n  \x3c!-- Macro for computing cylinder inertia --\x3e\r\n  <xacro:macro name="cylinder_inertia" params="mass radius length">\r\n    <inertial>\r\n      <origin xyz="0 0 ${-length/2}" rpy="0 0 0"/>\r\n      <mass value="${mass}"/>\r\n      <inertia\r\n        ixx="${mass * (3*radius*radius + length*length) / 12}"\r\n        ixy="0.0" ixz="0.0"\r\n        iyy="${mass * (3*radius*radius + length*length) / 12}"\r\n        iyz="0.0"\r\n        izz="${mass * radius * radius / 2}"/>\r\n    </inertial>\r\n  </xacro:macro>\r\n\r\n  \x3c!-- Torso link (root) --\x3e\r\n  <link name="torso">\r\n    <visual>\r\n      <geometry>\r\n        <box size="0.3 0.2 0.5"/>\r\n      </geometry>\r\n      <material name="grey">\r\n        <color rgba="0.5 0.5 0.5 1.0"/>\r\n      </material>\r\n    </visual>\r\n    <collision>\r\n      <geometry>\r\n        <box size="0.3 0.2 0.5"/>\r\n      </geometry>\r\n    </collision>\r\n    <inertial>\r\n      <mass value="15.0"/>\r\n      <inertia ixx="0.4" ixy="0.0" ixz="0.0"\r\n               iyy="0.5" iyz="0.0" izz="0.2"/>\r\n    </inertial>\r\n  </link>\r\n\r\n  \x3c!-- Instantiate left and right arms --\x3e\r\n  <xacro:arm_links side="left" reflect="1"/>\r\n  <xacro:arm_links side="right" reflect="-1"/>\r\n\r\n</robot>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"processing-xacro-files",children:"Processing Xacro Files"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Convert Xacro to URDF\r\nxacro humanoid_arm.urdf.xacro > humanoid_arm.urdf\r\n\r\n# View in RViz\r\nros2 launch urdf_tutorial display.launch.py model:=humanoid_arm.urdf.xacro\r\n\r\n# Check for errors\r\ncheck_urdf humanoid_arm.urdf\n"})}),"\n",(0,o.jsx)(e.h2,{id:"complete-humanoid-urdf-example",children:"Complete Humanoid URDF Example"}),"\n",(0,o.jsxs)(e.p,{children:["See the next chapter (",(0,o.jsx)(e.strong,{children:"Week 5: Complete URDF Example"}),") for a full working humanoid robot with torso, arms, legs, and hands\u2014ready for simulation in Gazebo and control with ros2_control."]}),"\n",(0,o.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Use Xacro for all but trivial robots"}),": Avoid copy-paste errors and enable easy parameter tuning"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Define inertial properties"}),": Physics simulation requires accurate mass/inertia"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Simplify collision geometry"}),": Use primitive shapes (boxes, cylinders) instead of complex meshes for performance"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Follow naming conventions"}),": Use ",(0,o.jsx)(e.code,{children:"<side>_<body_part>_<motion>"})," (e.g., ",(0,o.jsx)(e.code,{children:"left_shoulder_pitch"}),")"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Set realistic limits"}),": Joint limits should match hardware specifications"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Test incrementally"}),": Build robot link-by-link, testing visualization after each addition"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,o.jsxs)(e.p,{children:["The next chapter covers ",(0,o.jsx)(e.strong,{children:"ros2_control"}),", the framework for connecting URDF models to actual controllers (position, velocity, effort) and hardware interfaces. You'll learn how to make your URDF robot move in simulation and transition to real hardware."]}),"\n",(0,o.jsx)(e.h3,{id:"practice-exercise",children:"Practice Exercise"}),"\n",(0,o.jsx)(e.p,{children:"Extend the arm Xacro macro to include:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"A wrist rotation joint (continuous type)"}),"\n",(0,o.jsx)(e.li,{children:"A simple gripper with two fingers (prismatic joints)"}),"\n",(0,o.jsx)(e.li,{children:"Force/torque sensor link at the wrist (fixed joint)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Visualize in RViz and verify joint limits work as expected."})]})}function m(r={}){const{wrapper:e}={...(0,s.R)(),...r.components};return e?(0,o.jsx)(e,{...r,children:(0,o.jsx)(d,{...r})}):d(r)}},8453:(r,e,n)=>{n.d(e,{R:()=>t,x:()=>a});var i=n(6540);const o={},s=i.createContext(o);function t(r){const e=i.useContext(s);return i.useMemo(function(){return"function"==typeof r?r(e):{...e,...r}},[e,r])}function a(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(o):r.components||o:t(r.components),i.createElement(s.Provider,{value:e},r.children)}}}]);